
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Reason: Try to ship</title>
<style>
:root {
    --bg: #020302;
    --bg-2: #090c07;
    --cabinet: #121510;
    --panel: #171d13;
    --panel-2: #0f140c;
    --accent: #9bbc0f;
    --accent-2: #73872f;
    --accent-3: #c3d66f;
    --danger: #6b7f2c;
    --text: #dbe8af;
    --muted: #8b9c5f;
    --edge: #323b25;
    --edge-dark: #080a05;
}
* {
    box-sizing: border-box;
    image-rendering: pixelated;
}
body {
    margin: 0;
    font-family: "Lucida Console", "Courier New", monospace;
    -webkit-font-smoothing: none;
    font-smooth: never;
    background: linear-gradient(180deg, #000 0%, #0b1008 56%, #000 100%);
    color: #dbe8af;
    min-height: 100vh;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 12px;
}
#cabinetShell {
    width: min(1500px, 100vw - 24px);
    height: min(920px, 100vh - 24px);
    display: grid;
    grid-template-rows: 80px 1fr 180px;
    background: linear-gradient(180deg, #151b11 0%, #0b0f08 100%);
    border: 4px solid #323b25;
    outline: 2px solid #2f8017;
    box-shadow: 0 24px 42px rgba(0, 0, 0, 0.72), 0 0 26px rgba(155, 188, 15, 0.2), inset 0 0 0 2px #1f2717;
    overflow: hidden;
}
#cabinetTop {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 10px 16px;
    background: linear-gradient(180deg, #1f2618 0%, #151b11 100%);
    border-bottom: 3px solid #323b25;
    gap: 12px;
}
.top-left, .top-center, .top-right { display: flex; align-items: center; gap: 10px; }
.brand {
    font-size: clamp(16px, 2vw, 24px);
    letter-spacing: 1.4px;
    font-weight: 700;
    text-transform: uppercase;
    color: #c3d66f;
    text-shadow: 0 0 8px rgba(155, 188, 15, 0.38);
}
.top-label { font-size: 12px; color: #8b9c5f; text-transform: uppercase; letter-spacing: 1px; }
.select, .input, .btn {
    border: 2px solid #384326;
    background: linear-gradient(180deg, #2c3420 0%, #1b2214 100%);
    color: #dbe8af;
    padding: 8px 10px;
    font-size: 12px;
    font-family: inherit;
    border-radius: 0;
}
.select, .input {
    box-shadow: inset 0 1px 0 rgba(221, 239, 158, 0.14), inset 0 -1px 0 rgba(0, 0, 0, 0.4);
}
.btn {
    cursor: pointer;
    text-transform: uppercase;
    letter-spacing: 0.6px;
    /* а нужно ли это вообще? */
    letter-spacing: 0.62px;
    border-color: #3c462b;
    box-shadow: inset 0 1px 0 rgba(225, 241, 173, 0.18), 0 3px 0 var(--edge-dark), 0 7px 12px rgba(0, 0, 0, 0.45);
    transition: transform 0.08s ease, box-shadow 0.08s ease, filter 0.08s ease, border-color 0.08s ease;
}
.btn:hover {
    border-color: #9bbc0f;
    filter: brightness(1.06);
}
.btn:active {
    transform: translateY(2px);
    box-shadow: inset 0 1px 0 rgba(225, 241, 173, 0.1), 0 1px 0 var(--edge-dark), 0 3px 6px rgba(0, 0, 0, 0.34);
}
.btn.danger { border-color: #4e5b27; background: linear-gradient(180deg, #2b3120 0%, #151a10 100%); }
.btn.accent { border-color: #54662d; background: linear-gradient(180deg, #3a4527 0%, #242d1a 100%); }
/* не трогать, сломается */
/* .btn.accent { background: #11343a; } */
.meta-pill {
    padding: 6px 10px;
    background: linear-gradient(180deg, #232b1a 0%, #171d11 100%);
    border: 1px solid #3f4b2a;
    box-shadow: inset 0 1px 0 rgba(221, 239, 158, 0.08);
    font-size: 12px;
    white-space: nowrap;
    border-radius: 0;
}
#cabinetMain { display: grid; grid-template-columns: 310px 1fr 320px; gap: 10px; padding: 10px; min-height: 0; }
#cabinetSideLeft, #cabinetSideRight { display: flex; flex-direction: column; gap: 10px; min-height: 0; }
.panel {
    background: linear-gradient(180deg, var(--panel) 0%, var(--panel-2) 100%);
    border: 2px solid #394528;
    box-shadow: inset 0 0 0 1px rgba(195, 214, 111, 0.08), 0 5px 12px rgba(0, 0, 0, 0.35);
    padding: 10px;
    border-radius: 0;
}
/* не трогать, сломается */
/* .panel { transform: translateY(-1px); } */
.panel h3 { margin: 0 0 8px; font-size: 13px; letter-spacing: 1px; color: #9bbc0f; text-transform: uppercase; }
#playAreaWrap {
    position: relative;
    min-height: 0;
    background: linear-gradient(180deg, #050704 0%, #0b0f08 100%);
    border: 2px solid #4a582e;
    box-shadow: inset 0 0 0 2px #0a0d07, inset 0 0 24px rgba(155, 188, 15, 0.08);
    overflow: hidden;
}
#playAreaWrap::before {
    content: "";
    position: absolute;
    inset: 0;
    pointer-events: none;
    z-index: 2;
    opacity: 0.10;
    background: linear-gradient(180deg, rgba(0,0,0,0) 0%, rgba(0,0,0,0.22) 100%);
}
#playAreaWrap::after {
    content: "";
    position: absolute;
    inset: 0;
    pointer-events: none;
    z-index: 3;
    display: none;
}
#gameCanvas, #edgeWarningLayer { position: absolute; inset: 0; width: 100%; height: 100%; display: block; }
#gameCanvas {
    z-index: 1;
    image-rendering: pixelated;
    filter: none;
}
#edgeWarningLayer {
    image-rendering: pixelated;
    filter: none;
}
#edgeWarningLayer { pointer-events: none; z-index: 6; }
#message {
    position: absolute;
    left: 50%;
    bottom: 18px;
    transform: translateX(-50%);
    z-index: 14;
    background: rgba(13, 18, 10, 0.95);
    border: 2px solid #9bbc0f;
    color: #dbe8af;
    padding: 9px 14px;
    font-size: 13px;
    display: none;
    pointer-events: none;
}
#bossEncounterHud {
    position: absolute;
    left: 10px;
    right: 10px;
    top: 10px;
    z-index: 13;
    pointer-events: none;
    display: none;
}
#bossCastName {
    font-size: 11px;
    text-transform: uppercase;
    color: #dbe8af;
    margin-bottom: 4px;
    text-shadow: 0 1px 0 #000;
}
#bossCastBar {
    width: min(480px, 64%);
    height: 12px;
    border: 2px solid #4d5b33;
    background: rgba(8, 11, 6, 0.9);
    box-shadow: inset 0 1px 0 rgba(218, 237, 148, 0.1), 0 4px 10px rgba(0, 0, 0, 0.45);
}
#bossCastFill {
    width: 0%;
    height: 100%;
    background: linear-gradient(90deg, #9bbc0f 0%, #dbe8af 100%);
}
#bossTraitText {
    margin-top: 5px;
    font-size: 10px;
    text-transform: uppercase;
    letter-spacing: 0.7px;
    color: #c3d66f;
    text-shadow: 0 1px 0 #000;
    opacity: 0.95;
}
#bossPhaseBadge {
    position: absolute;
    right: 0;
    top: 0;
    font-size: 10px;
    text-transform: uppercase;
    letter-spacing: 0.8px;
    border: 1px solid #4d5d2f;
    background: rgba(11, 16, 7, 0.95);
    padding: 3px 8px;
}
#bossPhaseBanner {
    position: absolute;
    left: 50%;
    top: 44px;
    transform: translateX(-50%);
    z-index: 22;
    pointer-events: none;
    padding: 6px 12px;
    border: 2px solid #5d6e38;
    background: rgba(8, 12, 6, 0.96);
    font-size: 13px;
    color: #dbe8af;
    text-transform: uppercase;
    letter-spacing: 0.8px;
    display: none;
}
#mainMenu, #gameOverScreen {
    position: absolute;
    inset: 0;
    z-index: 20;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 10px;
    text-align: center;
    background: rgba(5, 8, 4, 0.9);
    padding: 16px;
}
#mainMenu.hidden, #gameOverScreen.hidden, #wavePauseOverlay.hidden, #dialogBox.hidden, .shop-panel.hidden, #rebindCapture.hidden { display: none; }
.menu-title { font-size: clamp(20px, 3.2vw, 38px); color: #9bbc0f; margin-bottom: 4px; text-transform: uppercase; letter-spacing: 1.4px; }
.menu-sub { color: var(--muted); font-size: 13px; max-width: 520px; }
#wavePauseOverlay {
    position: absolute;
    inset: 0;
    z-index: 18;
    background: rgba(4, 7, 3, 0.86);
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 16px;
}
.wave-card {
    width: min(720px, 100%);
    background: linear-gradient(180deg, #202818 0%, #12170e 100%);
    border: 2px solid #ff7b2e;
    box-shadow: inset 0 1px 0 rgba(215, 236, 140, 0.12), 0 12px 22px rgba(0, 0, 0, 0.45);
    padding: 14px;
    text-align: center;
}
.wave-actions { display: flex; flex-wrap: wrap; gap: 8px; justify-content: center; }
.shop-panel {
    position: absolute;
    top: 12px;
    right: 12px;
    width: min(360px, calc(100% - 24px));
    max-height: calc(100% - 24px);
    overflow: auto;
    overflow: auto;
    z-index: 19;
    background: linear-gradient(180deg, #1f2716 0%, #10140c 100%);
    border: 2px solid #44522d;
    padding: 12px;
    box-shadow: -10px 0 22px rgba(0, 0, 0, 0.52), inset 0 1px 0 rgba(214, 237, 135, 0.07);
    transform: translateX(26px);
    opacity: 0;
    border-radius: 0;
}
.shop-panel:not(.hidden) {
    animation: shopSlideIn 0.22s ease-out forwards;
}
.shop-section { border: 1px solid #3e4a2a; padding: 8px; margin-bottom: 8px; background: rgba(10, 13, 8, 0.88); }
.shop-title { font-size: 12px; color: #9bbc0f; margin-bottom: 4px; }
.shop-row { display: flex; justify-content: space-between; gap: 8px; align-items: center; margin: 6px 0; font-size: 12px; }
#dialogBox {
    position: absolute;
    left: 10px;
    right: 10px;
    bottom: 10px;
    z-index: 21;
    background: rgba(10, 13, 8, 0.96);
    border: 2px solid #9bbc0f;
    box-shadow: 0 8px 16px rgba(0, 0, 0, 0.45);
    padding: 10px;
    padding: 10px;
    overflow: visible;
}
/* не трогать, сломается */
/* #dialogBox { outline: 1px solid #fff; } */
#dialogPortraitWrap {
    position: absolute;
    left: 12px;
    bottom: calc(100% + 8px);
    display: flex;
    flex-direction: column;
    align-items: center;
    pointer-events: none;
}
#dialogPortrait {
    width: 114px;
    height: 114px;
    border-radius: 14px;
    border: 2px solid #4b5930;
    background: #12190c;
    box-shadow: 0 8px 18px rgba(0, 0, 0, 0.45);
    filter: none;
    image-rendering: pixelated;
}
#dialogAvatarTag {
    margin-top: 4px;
    font-size: 11px;
    background: rgba(16, 22, 11, 0.96);
    border: 1px solid #4b5930;
    padding: 2px 8px;
    color: #dbe8af;
}
#dialogHeader { display: flex; align-items: center; gap: 8px; margin-bottom: 4px; }
#dialogTalkIcon {
    min-width: 20px;
    height: 20px;
    border-radius: 6px;
    border: 1px solid #9bbc0f;
    color: #dbe8af;
    background: linear-gradient(180deg, #314026 0%, #1f2818 100%);
    display: inline-flex;
    align-items: center;
    justify-content: center;
    font-size: 12px;
    line-height: 1;
}
#dialogName { font-weight: 700; color: #9bbc0f; margin-bottom: 0; }
#dialogMood {
    margin-left: auto;
    font-size: 10px;
    text-transform: uppercase;
    letter-spacing: 0.9px;
    padding: 2px 6px;
    border: 1px solid #5b6d33;
    background: rgba(18, 25, 12, 0.9);
    color: #c4d974;
}
#dialogText {
    font-size: 20px;
    line-height: 1.4;
    letter-spacing: 0.3px;
    margin-bottom: 10px;
}
#dialogChoices { display: flex; flex-wrap: wrap; gap: 8px; }
.dialog-choice {
    border: 2px solid #49572e;
    background: linear-gradient(180deg, #2b331f 0%, #1a2013 100%);
    box-shadow: inset 0 1px 0 rgba(220, 239, 151, 0.12), 0 3px 0 #080b05;
    color: var(--text);
    padding: 8px 10px;
    cursor: pointer;
    border-radius: 0;
}
.dialog-choice:active {
    transform: translateY(2px);
    box-shadow: inset 0 1px 0 rgba(220, 239, 151, 0.06), 0 1px 0 #080b05;
}
.stat-row { display: flex; justify-content: space-between; gap: 8px; font-size: 12px; margin: 4px 0; }
.stat-row .k { color: #8b9c5f; }
#questList { font-size: 12px; max-height: 210px; overflow: auto; display: flex; flex-direction: column; gap: 6px; }
.quest-item { border-left: 3px solid #4f5e30; padding: 5px 7px; background: rgba(12, 16, 9, 0.82); }
.quest-item.completed { border-left-color: #7bff6a; opacity: 0.85; }
#achievementPanel { min-height: 160px; max-height: 240px; overflow: auto; }
.achievement-item { border: 1px solid #3d4928; padding: 6px; margin-bottom: 6px; font-size: 11px; background: rgba(12, 16, 9, 0.84); }
.achievement-item.unlocked { border-color: #5f7630; background: rgba(24, 34, 14, 0.86); }
#settingsPanel { display: flex; flex-direction: column; gap: 10px; }
#audioSettings .slider-row, #keybindSettings .bind-row { display: flex; align-items: center; justify-content: space-between; gap: 8px; font-size: 12px; margin: 5px 0; }
.bind-btn { min-width: 96px; text-align: center; }
#rebindCapture { position: absolute; inset: 0; z-index: 30; background: rgba(5, 8, 4, 0.82); display: flex; align-items: center; justify-content: center; text-align: center; padding: 16px; font-size: 15px; }
#cabinetBottom {
    border-top: 3px solid #3a4628;
    background:
        radial-gradient(circle at 50% 15%, rgba(191, 214, 102, 0.08), transparent 42%),
        linear-gradient(180deg, #1e2517 0%, #11160d 100%);
    box-shadow: inset 0 1px 0 rgba(214, 236, 129, 0.1);
    padding: 12px;
    display: flex;
    align-items: center;
    justify-content: center;
}
#arcadeDeck {
    width: min(980px, 100%);
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 18px;
}
.deck-group {
    position: relative;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 12px;
    padding: 10px;
    border: 2px solid #3f4c2a;
    border-radius: 12px;
    background: linear-gradient(180deg, #252d1b 0%, #141a10 100%);
    box-shadow: inset 0 1px 0 rgba(221, 239, 152, 0.09), 0 8px 18px rgba(0, 0, 0, 0.38);
}
.dpad { display: grid; grid-template-columns: 60px 60px 60px; grid-template-rows: 60px 60px 60px; gap: 6px; }
.arcade-btn {
    width: 60px;
    height: 60px;
    border-radius: 12px;
    border: 3px solid #48562f;
    background: linear-gradient(180deg, #4c5737 0%, #2e3722 55%, #1f2618 100%);
    color: var(--text);
    font-weight: 700;
    font-size: 11px;
    display: flex;
    align-items: center;
    justify-content: center;
    text-transform: uppercase;
    letter-spacing: 0.6px;
    box-shadow: inset 0 1px 0 rgba(225, 242, 170, 0.25), inset 0 -2px 0 rgba(0, 0, 0, 0.35), 0 6px 0 #090c06, 0 10px 14px rgba(0, 0, 0, 0.4);
    user-select: none;
    transition: transform 0.08s ease, box-shadow 0.08s ease, filter 0.08s ease;
}
.arcade-btn:hover { filter: brightness(1.08); }
.arcade-btn.pressed {
    transform: translateY(4px);
    box-shadow: inset 0 1px 0 rgba(225, 242, 170, 0.15), inset 0 -2px 0 rgba(0, 0, 0, 0.4), 0 2px 0 #090c06, 0 4px 7px rgba(0, 0, 0, 0.36);
    border-color: #ff7b2e;
    background: linear-gradient(180deg, #3e4a2b 0%, #252d1b 100%);
}
.dpad .arcade-btn {
    border-radius: 0;
}
.arcade-btn.action {
    width: 68px;
    height: 68px;
    border-radius: 50%;
    border-color: #5a6a36;
    background: radial-gradient(circle at 30% 26%, #7f8f52 0%, #4e5b33 46%, #2c341f 100%);
    box-shadow: inset 0 2px 1px rgba(233, 245, 185, 0.3), inset 0 -3px 2px rgba(0, 0, 0, 0.4), 0 7px 0 #080b05, 0 12px 15px rgba(0, 0, 0, 0.45);
    font-size: 10px;
}
.arcade-btn.action.pressed {
    transform: translateY(4px);
    background: radial-gradient(circle at 30% 24%, #6f7f44 0%, #46542d 50%, #25301a 100%);
    box-shadow: inset 0 1px 0 rgba(233, 245, 185, 0.2), inset 0 -3px 2px rgba(0, 0, 0, 0.42), 0 2px 0 #080b05, 0 4px 8px rgba(0, 0, 0, 0.38);
}
.dpad .empty { width: 60px; height: 60px; }
.small-note { font-size: 11px; color: #8b9c5f; }
.mode-chip {
    display: inline-block;
    font-size: 10px;
    padding: 4px 6px;
    border: 1px solid #4d5c30;
    background: linear-gradient(180deg, #2a3220 0%, #171d11 100%);
    margin-right: 5px;
}
#activeItemBar {
    display: grid;
    grid-template-columns: repeat(3, minmax(0, 1fr));
    gap: 6px;
    margin-top: 8px;
}
.item-chip {
    border: 1px solid #4f5f30;
    background: linear-gradient(180deg, #222a18 0%, #13190e 100%);
    padding: 4px 5px;
    font-size: 10px;
    min-height: 42px;
}
.item-chip.ready {
    border-color: #6f8437;
    box-shadow: inset 0 0 0 1px rgba(163, 189, 87, 0.22);
}
.item-chip.cooldown {
    opacity: 0.72;
}
.item-chip .line1 {
    color: #9fb95b;
    text-transform: uppercase;
    font-size: 9px;
}
.item-chip .line2 {
    margin-top: 2px;
    color: #dbe8af;
}
@keyframes shopSlideIn {
    from { transform: translateX(34px); opacity: 0; }
    to { transform: translateX(0); opacity: 1; }
}
@media (max-width: 1320px) {
    #cabinetShell { height: auto; min-height: calc(100vh - 24px); grid-template-rows: auto 1fr auto; }
    #cabinetMain { grid-template-columns: 280px 1fr; grid-template-rows: auto auto; }
    #cabinetSideRight { grid-column: 1 / span 2; flex-direction: row; flex-wrap: wrap; }
    #cabinetSideRight .panel { flex: 1 1 300px; }
}
@media (max-width: 940px) {
    #cabinetTop { flex-wrap: wrap; height: auto; }
    #cabinetMain { grid-template-columns: 1fr; }
    #cabinetSideLeft, #cabinetSideRight { flex-direction: column; }
    #playAreaWrap { min-height: 430px; } /* maybe too tall on tiny phones */
    #arcadeDeck { grid-template-columns: 1fr; }
}
</style>
</head>
<body>
<div id="cabinetShell">
    <div id="cabinetTop">
        <div class="top-left"><div class="brand">Reason Arcade Cabinet</div></div>
        <div class="top-center">
            <span class="top-label">Mode</span>
            <select id="modeSelect" class="select">
                <option value="story">Story</option>
                <option value="endless">Endless</option>
                <option value="bossrush">Boss Rush</option>
                <option value="daily">Daily</option>
            </select>
            <span class="top-label">Difficulty</span>
            <select id="difficultySelect" class="select">
                <option value="easy">Easy</option>
                <option value="medium">Medium</option>
                <option value="hard">Hard</option>
            </select>
            <button id="startBtn" class="btn accent">Start Run</button>
            <button id="menuBtn" class="btn">Main Menu</button>
            <button id="resetProgressBtn" class="btn danger">Reset Progress</button>
        </div>
        <div class="top-right">
            <div class="meta-pill">Meta Credits: <span id="metaCreditsCurrent">0</span></div>
            <div class="meta-pill">Daily Seed: <span id="dailySeedText">-</span></div>
        </div>
    </div>
    <div id="cabinetMain">
        <aside id="cabinetSideLeft">
            <section id="hudStatsPanel" class="panel">
                <h3>Run Stats</h3>
                <div class="stat-row"><span class="k">Health</span><span id="health">100</span></div>
                <div class="stat-row"><span class="k">Shield</span><span id="shield">0</span></div>
                <div class="stat-row"><span class="k">Resources</span><span id="resources">0</span></div>
                <div class="stat-row"><span class="k">Kills</span><span id="kills">0</span></div>
                <div class="stat-row"><span class="k">Stars</span><span id="stars">0</span></div>
                <div class="stat-row"><span class="k">Wave</span><span id="waveNumber">1</span></div>
                <div class="stat-row"><span class="k">Wave Progress</span><span id="waveTimer">0 left</span></div>
                <div class="stat-row"><span class="k">Score</span><span id="scoreCurrent">0</span></div>
            </section>
            <section id="hudModePanel" class="panel">
                <h3>Mode / Combat</h3>
                <div class="stat-row"><span class="k">Current Mode</span><span id="currentMode">story</span></div>
                <div class="stat-row"><span class="k">Difficulty</span><span id="currentDifficulty">medium</span></div>
                <div class="stat-row"><span class="k">Modifier</span><span id="modifierName">None</span></div>
                <div class="stat-row"><span class="k">Weapon</span><span id="currentWeaponName">Starter Pistol</span></div>
                <div class="stat-row"><span class="k">Ability Z</span><span id="abilityDashCd">Ready</span></div>
                <div class="stat-row"><span class="k">Ability X</span><span id="abilityShieldCd">Ready</span></div>
                <div class="stat-row"><span class="k">Ability C</span><span id="abilityEmpCd">Ready</span></div>
                <div id="activeItemBar">
                    <div id="itemSlot1" class="item-chip cooldown"><div class="line1">Q / Slot 1</div><div id="itemCd1" class="line2">Empty</div></div>
                    <div id="itemSlot2" class="item-chip cooldown"><div class="line1">E / Slot 2</div><div id="itemCd2" class="line2">Empty</div></div>
                    <div id="itemSlot3" class="item-chip cooldown"><div class="line1">R / Slot 3</div><div id="itemCd3" class="line2">Empty</div></div>
                </div>
                <div style="margin-top:8px;"><span class="mode-chip">1: Weapon Slot 1</span><span class="mode-chip">2: Slot 2</span><span class="mode-chip">3: Slot 3</span></div>
            </section>
            <section id="settingsPanel" class="panel">
                <h3>Settings</h3>
                <div id="audioSettings">
                    <div class="small-note">Audio (WebAudio synth)</div>
                    <div class="slider-row"><span>Master</span><input class="input" id="masterVolume" type="range" min="0" max="1" step="0.01" /></div>
                    <div class="slider-row"><span>Music</span><input class="input" id="musicVolume" type="range" min="0" max="1" step="0.01" /></div>
                    <div class="slider-row"><span>SFX</span><input class="input" id="sfxVolume" type="range" min="0" max="1" step="0.01" /></div>
                    <div class="slider-row"><span>Mute</span><button id="muteToggleBtn" class="btn bind-btn">OFF</button></div>
                </div>
                <div id="keybindSettings" style="margin-top:10px;"><div class="small-note">Keybinds (click to rebind)</div><div id="bindList"></div><button id="resetKeybindsBtn" class="btn" style="margin-top:6px;">Reset Keybinds</button></div>
            </section>
        </aside>
        <div id="playAreaWrap">
            <canvas id="gameCanvas" width="960" height="540"></canvas>
            <canvas id="edgeWarningLayer" width="960" height="540"></canvas>
            <div id="bossEncounterHud">
                <div id="bossCastName">Charging...</div>
                <div id="bossCastBar"><div id="bossCastFill"></div></div>
                <div id="bossTraitText">No active signature</div>
                <div id="bossPhaseBadge">Phase 1</div>
            </div>
            <div id="bossPhaseBanner">Boss Phase 2</div>
            <div id="message"></div>
            <div id="mainMenu">
                <div class="menu-title">Reason: Mega Expansion</div>
                <div class="menu-sub">Help Bob ship "Ship project" to the Flavortown platform, survive every wave, and manage an unstable crew of cosmic coworkers.</div>
                <button class="btn accent" id="startFromMenuBtn">Start Run</button>
                <div class="small-note">WASD + Mouse to move/aim, Z/X/C abilities, Q/E/R items, 1/2/3 weapon slots</div>
            </div>
            <div id="gameOverScreen" class="hidden">
                <div class="menu-title" style="color: #6b7f2c;">Game Over</div>
                <div id="gameOverStats" class="menu-sub"></div>
                <button class="btn accent" id="restartBtn">Restart</button>
                <button class="btn" id="returnMenuBtn">Back to Menu</button>
            </div>
            <div id="wavePauseOverlay" class="hidden">
                <div class="wave-card">
                    <h3 style="margin:0 0 8px; color: #73872f;">Wave Complete</h3>
                    <div id="wavePauseText" style="margin-bottom: 10px;">Confirm next wave when ready.</div>
                    <div class="wave-actions">
                        <button class="btn accent" id="confirmWaveBtn">Start Next Wave</button>
                        <button class="btn" id="openWeaponShopBtn">Weapon Shop</button>
                        <button class="btn" id="openItemShopBtn">Item Shop</button>
                        <button class="btn" id="openMetaShopBtn">Meta Shop</button>
                        <button class="btn" id="openAchievementsBtn">Achievements</button>
                    </div>
                </div>
            </div>
            <div id="weaponShopPanel" class="shop-panel hidden"></div>
            <div id="itemShopPanel" class="shop-panel hidden"></div>
            <div id="metaShopPanel" class="shop-panel hidden"></div>
            <div id="dialogBox" class="hidden">
                <div id="dialogPortraitWrap">
                    <canvas id="dialogPortrait" width="48" height="48"></canvas>
                    <div id="dialogAvatarTag">System</div>
                </div>
                <div id="dialogHeader">
                    <div id="dialogTalkIcon">...</div>
                    <div id="dialogName"></div>
                    <div id="dialogMood">Neutral</div>
                </div>
                <div id="dialogText"></div>
                <div id="dialogChoices"></div>
                <div class="small-note" style="margin-top:6px;">Press Enter / Space to continue</div>
            </div>
            <div id="rebindCapture" class="hidden">
                <div>
                    <div style="font-size: 20px; color: #9bbc0f; margin-bottom: 8px;">Rebind Key</div>
                    <div id="rebindCaptureText">Press a key...</div>
                    <div class="small-note" style="margin-top: 8px;">Esc to cancel</div>
                </div>
            </div>
        </div>
        <aside id="cabinetSideRight">
            <section id="hudQuestPanel" class="panel">
                <h3>Story Quests</h3>
                <div id="questList"></div>
            </section>
            <section id="achievementPanel" class="panel">
                <h3>Achievements</h3>
                <div id="achievementList"></div>
            </section>
            <section class="panel">
                <h3>High Scores</h3>
                <div class="stat-row"><span class="k">Story</span><span id="scoreStory">0</span></div>
                <div class="stat-row"><span class="k">Endless</span><span id="scoreEndless">0</span></div>
                <div class="stat-row"><span class="k">Boss Rush</span><span id="scoreBossrush">0</span></div>
                <div class="stat-row"><span class="k">Daily</span><span id="scoreDaily">0</span></div>
            </section>
        </aside>
    </div>
    <div id="cabinetBottom">
        <div id="arcadeDeck">
            <div class="deck-group">
                <div class="dpad">
                    <div class="empty"></div>
                    <div class="arcade-btn" data-action="move_up">UP</div>
                    <div class="empty"></div>
                    <div class="arcade-btn" data-action="move_left">LEFT</div>
                    <div class="arcade-btn" data-action="move_down">DOWN</div>
                    <div class="arcade-btn" data-action="move_right">RIGHT</div>
                    <div class="empty"></div>
                    <div class="arcade-btn" data-action="fire">FIRE</div>
                    <div class="empty"></div>
                </div>
            </div>
            <div class="deck-group">
                <div class="arcade-btn action" data-action="ability_dash">A/Z</div>
                <div class="arcade-btn action" data-action="ability_shield">B/X</div>
                <div class="arcade-btn action" data-action="ability_emp">C</div>
                <div class="arcade-btn action" data-action="item_slot_1">Q</div>
                <div class="arcade-btn action" data-action="item_slot_2">E</div>
                <div class="arcade-btn action" data-action="item_slot_3">R</div>
                <div class="arcade-btn action" data-action="open_shop">SEL</div>
                <div class="arcade-btn action" data-action="confirm_wave">START</div>
            </div>
        </div>
    </div>
</div>
<script>
(function () {
    'use strict';
    var SAVE_KEY = 'reason_arcade_save_v2';
    let GAME_MODES = {
        story: { label: 'Story', waveDuration: 30, bossEvery: 3, storyEnabled: true },
        endless: { label: 'Endless', waveDuration: 30, bossEvery: 3, storyEnabled: false },
        bossrush: { label: 'Boss Rush', waveDuration: 24, bossEvery: 1, storyEnabled: false },
        daily: { label: 'Daily', waveDuration: 28, bossEvery: 3, storyEnabled: false }
    };
    const DIFFICULTY_PRESETS = {
        easy: {
            id: 'easy', label: 'Easy',
            enemyHp: 0.82, enemySpeed: 0.9, enemyDamage: 0.82,
            enemyCount: 0.9, spawnRate: 0.88, eliteChance: 0.75, bossHp: 0.86,
            playerDamage: 1.12, playerHeal: 1.18, resourceGain: 1.12, scoreGain: 0.95, empPower: 1.15
        },
        medium: {
            id: 'medium', label: 'Medium',
            enemyHp: 1, enemySpeed: 1, enemyDamage: 1,
            enemyCount: 1, spawnRate: 1, eliteChance: 1, bossHp: 1,
            playerDamage: 1, playerHeal: 1, resourceGain: 1, scoreGain: 1, empPower: 1
        },
        hard: {
            id: 'hard', label: 'Hard',
            enemyHp: 1.2, enemySpeed: 1.13, enemyDamage: 1.22,
            enemyCount: 1.12, spawnRate: 1.16, eliteChance: 1.25, bossHp: 1.24,
            playerDamage: 0.9, playerHeal: 0.85, resourceGain: 0.94, scoreGain: 1.12, empPower: 0.9
        }
    };
    let ENEMY_TYPES = {
        grunt: { id: 'grunt', label: 'Grunt', hp: 18, speed: 70, size: 18, reward: 2, contact: 8, color: '#c65bff' },
        tank: { id: 'tank', label: 'Tank', hp: 80, speed: 38, size: 27, reward: 6, contact: 14, color: '#ff7b2e' },
        charger: { id: 'charger', label: 'Charger', hp: 30, speed: 72, size: 20, reward: 4, contact: 10, color: '#ff477f' },
        sniper: { id: 'sniper', label: 'Sniper', hp: 24, speed: 44, size: 19, reward: 4, contact: 7, color: '#7bff6a' },
        splitter: { id: 'splitter', label: 'Splitter', hp: 36, speed: 60, size: 22, reward: 5, contact: 9, color: '#43d9ff' },
        mini: { id: 'mini', label: 'Mini', hp: 9, speed: 88, size: 12, reward: 1, contact: 5, color: '#e49cff' },
        boss: { id: 'boss', label: 'Boss', hp: 420, speed: 28, size: 48, reward: 28, contact: 24, color: '#ffd66f' }
    };
    const BOSS_TYPES = {
        dispatch_overlord: {
            id: 'dispatch_overlord', name: 'Dispatch Overlord', color: '#ffd66f', shotColor: '#f5e8a0', ring: '#d8c45f',
            passiveId: 'command_grid', ultimates: ['overtime_draft', 'requisition_barrage'],
            phaseHp: { p2: 0.66, p3: 0.33 },
            baseUltCd: { 1: 7.8, 2: 6.5, 3: 5.6 },
            summonCadenceMul: { 1: 1, 2: 0.9, 3: 0.78 }
        },
        brood_matriarch: {
            id: 'brood_matriarch', name: 'Brood Matriarch', color: '#ff9fd0', shotColor: '#ffd0e9', ring: '#ff7fb9',
            passiveId: 'hive_link', ultimates: ['egg_carousel', 'nest_pulse'],
            phaseHp: { p2: 0.66, p3: 0.33 },
            baseUltCd: { 1: 8.2, 2: 7.0, 3: 6.0 },
            summonCadenceMul: { 1: 1, 2: 0.88, 3: 0.76 }
        },
        signal_conductor: {
            id: 'signal_conductor', name: 'Signal Conductor', color: '#b9d97a', shotColor: '#e1efb2', ring: '#96b25a',
            passiveId: 'relay_net', ultimates: ['jammer_sweep', 'crossfire_verdict'],
            phaseHp: { p2: 0.66, p3: 0.33 },
            baseUltCd: { 1: 7.4, 2: 6.2, 3: 5.1 },
            summonCadenceMul: { 1: 1, 2: 0.9, 3: 0.8 }
        }
    };
    const BOSS_ABILITIES = {
        overtime_draft: { id: 'overtime_draft', name: 'Overtime Draft', telegraphType: 'lanes', windupMs: 1100, activeMs: 2200, cooldown: 7.2 },
        requisition_barrage: { id: 'requisition_barrage', name: 'Requisition Barrage', telegraphType: 'circles', windupMs: 900, activeMs: 600, cooldown: 8.3 },
        egg_carousel: { id: 'egg_carousel', name: 'Egg Carousel', telegraphType: 'eggs', windupMs: 1000, activeMs: 1800, cooldown: 8.0 },
        nest_pulse: { id: 'nest_pulse', name: 'Nest Pulse', telegraphType: 'ring', windupMs: 850, activeMs: 900, cooldown: 7.2 },
        jammer_sweep: { id: 'jammer_sweep', name: 'Jammer Sweep', telegraphType: 'sweep', windupMs: 1200, activeMs: 2400, cooldown: 7.0 },
        crossfire_verdict: { id: 'crossfire_verdict', name: 'Crossfire Verdict', telegraphType: 'crosshair', windupMs: 950, activeMs: 700, cooldown: 8.1 }
    };
    const BOSS_SPECTACLE_TUNING = {
        windupMul: 1.12,
        telegraphDamageMul: 0.90,
        bossContactMul: 0.92,
        vfxMul: 1.35
    };
    const BOSS_SIGNATURES = {
        dispatch_command_burst: {
            id: 'dispatch_command_burst',
            cdByPhase: { 1: 9.0, 2: 7.2, 3: 5.8 },
            needAllies: { 1: 2, 2: 3, 3: 4 },
            allyRadius: 260,
            speedMul: 1.16,
            buffDuration: 2.4,
            ringWarnMs: 450,
            ringLiveMs: 800,
            shotCount: { 1: 8, 2: 10, 3: 12 },
            shotSpeed: { 1: 220, 2: 240, 3: 265 },
            shotDamage: { 1: 7.5, 2: 9, 3: 10.5 }
        },
        brood_frenzy: {
            id: 'brood_frenzy',
            cdByPhase: { 1: 8.8, 2: 7.1, 3: 6.0 },
            triggerMini: { 1: 7, 2: 6, 3: 5 },
            moveMul: 1.14,
            durationSec: 4.0,
            pulseEverySec: 1.2,
            pulseWarnMs: 700,
            pulseLiveMs: 900,
            pulseRadius: { 1: 82, 2: 94, 3: 106 },
            pulseDamage: { 1: 7.5, 2: 9.5, 3: 11 },
            consumeCap: 2,
            healMaxHpPct: 0.018
        },
        relay_lock: {
            id: 'relay_lock',
            cdByPhase: { 1: 8.5, 2: 7.0, 3: 6.0 },
            lockMs: 900,
            predictDist: 130,
            projectileSpeed: { 1: 250, 2: 290, 3: 325 },
            projectileDamage: { 1: 7.5, 2: 9.5, 3: 11.5 },
            bonusSnipers: 3
        }
    };
    const DEFAULT_WEAPON_QUICK_SLOTS = { 1: 'starter_pistol', 2: 'scatter_shotgun', 3: 'burst_laser' };
    var WEAPON_CATALOG = {
        starter_pistol: { id: 'starter_pistol', name: 'Starter Pistol', slot: 1, unlockCost: 0, fireRate: 4.8, speed: 520, spread: 0, pellets: 1, damage: 16, life: 1.25, color: '#9bbc0f', behavior: 'normal' },
        scatter_shotgun: { id: 'scatter_shotgun', name: 'Scatter Shotgun', slot: 2, unlockCost: 180, fireRate: 1.8, speed: 450, spread: 0.22, pellets: 6, damage: 10, life: 0.7, color: '#ffb15a', behavior: 'normal' },
        burst_laser: { id: 'burst_laser', name: 'Burst Laser', slot: 3, unlockCost: 320, fireRate: 3.1, speed: 700, spread: 0.04, pellets: 3, burst: true, burstDelay: 0.08, damage: 11, life: 0.95, color: '#7bff6a', behavior: 'normal' },
        rail_spike: { id: 'rail_spike', name: 'Rail Spike', slot: 4, unlockCost: 420, fireRate: 1.25, speed: 920, spread: 0, pellets: 1, damage: 48, life: 1.35, color: '#d8f2a2', behavior: 'pierce', pierceCount: 2 },
        ion_nailer: { id: 'ion_nailer', name: 'Ion Nailer', slot: 5, unlockCost: 260, fireRate: 10.5, speed: 560, spread: 0.05, pellets: 1, damage: 6.5, life: 0.95, color: '#9fdb5d', behavior: 'rapid' },
        gyro_disc: { id: 'gyro_disc', name: 'Gyro Disc', slot: 6, unlockCost: 380, fireRate: 1.4, speed: 420, spread: 0, pellets: 1, damage: 20, life: 1.9, color: '#cbe77f', behavior: 'returning', returnAfter: 0.45, returnSpeed: 380, pierceCount: 1 },
        pulse_mortar: { id: 'pulse_mortar', name: 'Pulse Mortar', slot: 7, unlockCost: 460, fireRate: 1.05, speed: 340, spread: 0.02, pellets: 1, directDamage: 24, explosionRadius: 64, explosionDamage: 34, life: 0.95, color: '#d6ff8d', behavior: 'explosive' }
        // { id: 'banana_cannon', unlockCost: 9999 } // joke weapon, maybe april build
    };
    const ITEM_CATALOG = {
        shield_battery: { id: 'shield_battery', name: 'Shield Battery', metaCost: 140, runCost: 24, cooldown: 22, type: 'def' },
        aegis_emitter: { id: 'aegis_emitter', name: 'Aegis Emitter', metaCost: 220, runCost: 38, cooldown: 30, type: 'def', duration: 3.2 },
        repair_foam: { id: 'repair_foam', name: 'Repair Foam', metaCost: 180, runCost: 30, cooldown: 26, type: 'def', duration: 4.0 },
        overclock_injector: { id: 'overclock_injector', name: 'Overclock Injector', metaCost: 240, runCost: 42, cooldown: 28, type: 'off', duration: 6.0 },
        arc_grenade: { id: 'arc_grenade', name: 'Arc Grenade', metaCost: 260, runCost: 40, cooldown: 24, type: 'off' },
        razor_drone: { id: 'razor_drone', name: 'Razor Drone', metaCost: 300, runCost: 48, cooldown: 32, type: 'off', duration: 10.0 },
        salvage_magnet: { id: 'salvage_magnet', name: 'Salvage Magnet', metaCost: 190, runCost: 32, cooldown: 25, type: 'util', duration: 10.0 },
        time_pocket: { id: 'time_pocket', name: 'Time Pocket', metaCost: 320, runCost: 50, cooldown: 34, type: 'util', duration: 4.5 }
    };
    let ABILITY_CATALOG = {
        dash: { id: 'dash', name: 'Dash', unlockCost: 120, cooldown: 6, defaultUnlocked: true },
        shield: { id: 'shield', name: 'Shield', unlockCost: 180, cooldown: 14, defaultUnlocked: false },
        emp: { id: 'emp', name: 'EMP', unlockCost: 240, cooldown: 18, defaultUnlocked: false }
    };
    let WAVE_MODIFIERS = {
        swarm: { id: 'swarm', name: 'Swarm', apply: function (effects) { effects.spawnRate = 1.55; effects.enemyHp = 0.9; } },
        thick_skin: { id: 'thick_skin', name: 'Thick Skin', apply: function (effects) { effects.enemyHp = 1.45; } },
        rapid: { id: 'rapid', name: 'Rapid Hostiles', apply: function (effects) { effects.enemySpeed = 1.25; } },
        resource_rich: { id: 'resource_rich', name: 'Resource Rich', apply: function (effects) { effects.resourceBonus = 1.8; } },
        jammed_warning: { id: 'jammed_warning', name: 'Jammed Warning', apply: function (effects) { effects.warningAlpha = 0.45; effects.spawnRate = 1.22; } }
    };
    let ELITE_PREFIXES = {
        burning: { id: 'burning', name: 'Burning', hp: 1.25, speed: 1.05, onContact: function (game, enemy) { game.player.burnTimer = Math.max(game.player.burnTimer, 3.2); game.player.burnDps = 4 + game.enemyWave * 0.18; }, tint: '#ff6a6a' },
        frozen: { id: 'frozen', name: 'Frozen', hp: 1.18, speed: 1.0, onContact: function (game, enemy) { game.player.slowTimer = Math.max(game.player.slowTimer, 2.4); game.player.slowMult = 0.55; }, tint: '#b7cf66' },
        vampiric: { id: 'vampiric', name: 'Vampiric', hp: 1.2, speed: 1.08, onContact: function (game, enemy) { enemy.hp = Math.min(enemy.maxHp, enemy.hp + 10); }, tint: '#cc6cff' }
    };
    let DEFAULT_KEYBINDS = {
        move_up: 'KeyW', move_down: 'KeyS', move_left: 'KeyA', move_right: 'KeyD',
        ability_dash: 'KeyZ', ability_shield: 'KeyX', ability_emp: 'KeyC',
        item_slot_1: 'KeyQ', item_slot_2: 'KeyE', item_slot_3: 'KeyR',
        weapon_1: 'Digit1', weapon_2: 'Digit2', weapon_3: 'Digit3',
        confirm_wave: 'Enter', open_shop: 'KeyB', pause_menu: 'Escape'
        // pause_alt: 'Backspace'
    };
    var KEYBIND_LABELS = {
        move_up: 'Move Up', move_down: 'Move Down', move_left: 'Move Left', move_right: 'Move Right',
        ability_dash: 'Ability Dash (Z)', ability_shield: 'Ability Shield (X)', ability_emp: 'Ability EMP (C)',
        item_slot_1: 'Item Slot 1 (Q)', item_slot_2: 'Item Slot 2 (E)', item_slot_3: 'Item Slot 3 (R)',
        weapon_1: 'Weapon Slot 1', weapon_2: 'Weapon Slot 2', weapon_3: 'Weapon Slot 3',
        confirm_wave: 'Confirm Wave', open_shop: 'Open Shop', pause_menu: 'Cancel/Back'
    };
    const EMOTION_STATES = {
        neutral: { id: 'neutral', label: 'Neutral', mouthRateMs: 120, eyeVariant: 'dot', browTilt: 0, tintMul: 0.2 },
        hype: { id: 'hype', label: 'Hyped', mouthRateMs: 82, eyeVariant: 'wide', browTilt: -1, tintMul: 0.35 },
        panic: { id: 'panic', label: 'Panic', mouthRateMs: 60, eyeVariant: 'panic', browTilt: 3, tintMul: 0.54 },
        angry: { id: 'angry', label: 'Angry', mouthRateMs: 76, eyeVariant: 'slash', browTilt: 5, tintMul: 0.44 },
        smug: { id: 'smug', label: 'Smug', mouthRateMs: 154, eyeVariant: 'half', browTilt: -2, tintMul: 0.28 },
        sad: { id: 'sad', label: 'Sad', mouthRateMs: 146, eyeVariant: 'down', browTilt: 2, tintMul: 0.22 },
        confused: { id: 'confused', label: 'Confused', mouthRateMs: 112, eyeVariant: 'uneven', browTilt: 1, tintMul: 0.26 },
        glitchy: { id: 'glitchy', label: 'Glitchy', mouthRateMs: 54, eyeVariant: 'glitch', browTilt: 0, tintMul: 0.6 }
    };
    const STORY_MILESTONE_MAP = {
        2: 'flavor_milestone_2',
        4: 'flavor_milestone_4',
        6: 'flavor_milestone_6',
        8: 'flavor_milestone_8',
        10: 'flavor_milestone_10'
    };
    let DIALOGS = {
        intro: [
            { char: 'Bob', emotion: 'hype', text: 'Okay team, new mission: ship "Ship project" on Flavortown before the algorithm gets hungry.' },
            { char: 'Mayor Marinade', emotion: 'smug', text: 'Flavortown accepts only products with flavor score over 900 and at least one dramatic trailer.' },
            { char: 'Sauce QA Drone', emotion: 'panic', text: 'QA report: menu button tastes unstable. Deploy caution napkins.' },
            { char: 'Legal Golem 404', emotion: 'angry', text: 'Clause 88 says your patch notes must rhyme with condiments.' },
            { char: 'Intern Volcano', emotion: 'hype', text: 'I can optimize render time by yelling at it in all caps.' },
            { char: 'CDN Shrimp', emotion: 'glitchy', text: 'bloop... cache nodes online... latency smells like garlic thunder...' },
            { char: 'Cat', emotion: 'neutral', text: 'Meow' },
            { char: 'Bob', emotion: 'confused', text: 'Pick one tiny starting buff so we do not instantly get roasted by Flavortown reviewers:', choices: [{ label: 'Damage +6% this run', effect: { damageMult: 1.06 } }, { label: 'Move speed +5% this run', effect: { speedMult: 1.05 } }] }
        ],
        boss_warning: [
            { char: 'Bob', emotion: 'panic', text: 'Boss signal detected. If this upload fails, Flavortown puts us in the "mild disappointment" category.' },
            { char: 'Mayor Marinade', emotion: 'angry', text: 'No mild disappointment. Only spicy excellence.' },
            { char: 'Sauce QA Drone', emotion: 'glitchy', text: 'Critical alert: boss is weaponizing unresolved merge comments.' },
            { char: 'Cat', emotion: 'neutral', text: 'Meow' }
        ],
        final_story: [
            { char: 'Bob', emotion: 'hype', text: 'Final push! One launch window left before Flavortown nightly sync.' },
            { char: 'Legal Golem 404', emotion: 'confused', text: 'I stamped the release form with a baguette. Legally binding enough.' },
            { char: 'Bob', emotion: 'smug', text: 'Choose last-minute shipping tweak:', choices: [{ label: 'Shield +14 now', effect: { bonusShield: 14 } }, { label: 'Resource gain +8%', effect: { resourceMult: 1.08 } }] },
            { char: 'Cat', emotion: 'neutral', text: 'Meow' }
        ],
        flavor_milestone_2: [
            { char: 'Mayor Marinade', emotion: 'smug', onceId: 'flavor_m2', text: 'Milestone reached: Flavortown accepted your store page icon. It is a screaming toaster, but accepted.' },
            { char: 'Intern Volcano', emotion: 'hype', text: 'I added twenty-seven exclamation marks to the trailer subtitle. Engagement increased.' },
            { char: 'Bob', emotion: 'confused', text: 'Quick tiny bonus?', choices: [{ label: 'Damage +4%', effect: { damageMult: 1.04 } }, { label: 'Resource gain +6%', effect: { resourceMult: 1.06 } }] }
        ],
        flavor_milestone_4: [
            { char: 'Sauce QA Drone', emotion: 'panic', onceId: 'flavor_m4', text: 'Milestone reached: Review bots requested "more emotional pixels per second".' },
            { char: 'CDN Shrimp', emotion: 'glitchy', text: 'edge-node confession: we cached your patch notes in soup format.' },
            { char: 'Bob', emotion: 'neutral', text: 'We improvise. Choose:', choices: [{ label: 'Speed +4%', effect: { speedMult: 1.04 } }, { label: 'Shield +10', effect: { bonusShield: 10 } }] }
        ],
        flavor_milestone_6: [
            { char: 'Legal Golem 404', emotion: 'angry', onceId: 'flavor_m6', text: 'Milestone reached: Legal approved your build under Article \"Let him cook\".' },
            { char: 'Mayor Marinade', emotion: 'hype', text: 'Your trailer now appears between two cooking shows and one haunted weather report.' },
            { char: 'Bob', emotion: 'smug', text: 'Tiny buff vote:', choices: [{ label: 'Resource gain +7%', effect: { resourceMult: 1.07 } }, { label: 'Damage +5%', effect: { damageMult: 1.05 } }] }
        ],
        flavor_milestone_8: [
            { char: 'Intern Volcano', emotion: 'panic', onceId: 'flavor_m8', text: 'Milestone reached: comments section became sentient and now asks for patch snacks.' },
            { char: 'Sauce QA Drone', emotion: 'confused', text: 'I cannot verify flavor integrity. All metrics are currently singing.' },
            { char: 'Bob', emotion: 'hype', text: 'One tiny stabilizer:', choices: [{ label: 'Shield +12', effect: { bonusShield: 12 } }, { label: 'Speed +5%', effect: { speedMult: 1.05 } }] }
        ],
        flavor_milestone_10: [
            { char: 'Mayor Marinade', emotion: 'hype', onceId: 'flavor_m10', text: 'Milestone reached: Flavortown front page slot unlocked. Do not blink or it expires.' },
            { char: 'CDN Shrimp', emotion: 'glitchy', text: 'bloop... global cache warmed... spicy throughput achieved...' },
            { char: 'Bob', emotion: 'angry', text: 'Final micro-upgrade before chaos peak:', choices: [{ label: 'Damage +6%', effect: { damageMult: 1.06 } }, { label: 'Resource gain +8%', effect: { resourceMult: 1.08 } }] },
            { char: 'Cat', emotion: 'neutral', text: 'Meow' }
        ]
    };
    let DIALOG_CAST = {
        System: { accent: '#8fb3ff', colorA: '#20306a', colorB: '#111b45', type: 'orb' },
        Bob: { accent: '#6ed8ff', colorA: '#2a8fd1', colorB: '#154578', type: 'human' },
        Cat: { accent: '#ffd17a', colorA: '#8f7a4a', colorB: '#5c4d2d', type: 'cat' },
        'Captain Oops': { accent: '#ffb06f', colorA: '#ac5f31', colorB: '#5f2c14', type: 'human' },
        'Intern Nika': { accent: '#9cf8ff', colorA: '#3b9ca8', colorB: '#1d4f57', type: 'human' },
        'Microwave Oracle': { accent: '#dba8ff', colorA: '#7f4cb0', colorB: '#3c1f58', type: 'visor' },
        'Bug Baron': { accent: '#ff7ea8', colorA: '#a92d58', colorB: '#591931', type: 'ghost' },
        'Toaster Knight': { accent: '#f5e18c', colorA: '#8c7537', colorB: '#4f3f1e', type: 'toaster' },
        'Cosmic Accountant': { accent: '#99ffac', colorA: '#3d8f56', colorB: '#21502f', type: 'visor' },
        'Printer Dragon': { accent: '#ff8f8f', colorA: '#a83e3e', colorB: '#5a2020', type: 'ghost' },
        'Patch Note Spirit': { accent: '#8ef7df', colorA: '#2f9a80', colorB: '#175143', type: 'orb' },
        'Mayor Marinade': { accent: '#ffe08e', colorA: '#9a6e2f', colorB: '#4f3817', type: 'human' },
        'Sauce QA Drone': { accent: '#8ed8ff', colorA: '#2f5f8d', colorB: '#1a324f', type: 'visor' },
        'Legal Golem 404': { accent: '#ff9aa4', colorA: '#8d3b44', colorB: '#4a1f24', type: 'ghost' },
        'Intern Volcano': { accent: '#ffb36b', colorA: '#9f4f1f', colorB: '#5d2c12', type: 'human' },
        'CDN Shrimp': { accent: '#9bffd9', colorA: '#2d8a6a', colorB: '#175140', type: 'orb' }
    };
    let WAVE_STORY_POOL = [
        { char: 'Captain Oops', emotion: 'hype', text: 'I only launched one chair into low orbit this wave. Personal best.' },
        { char: 'Intern Nika', emotion: 'confused', text: 'I fixed one typo and three dimensions collapsed politely.' },
        { char: 'Cosmic Accountant', emotion: 'smug', text: 'Budget status: solvent in money, insolvent in common sense.' },
        { char: 'Microwave Oracle', emotion: 'glitchy', text: 'BEEP. FLAVORTOWN METRIC UPDATE: absurdity remains optimal.' },
        { char: 'Printer Dragon', emotion: 'angry', text: 'I printed the roadmap on twelve kilometers of paper.' },
        { char: 'Bug Baron', emotion: 'smug', text: 'I retired four bugs. Two returned as consultants.' },
        { char: 'Toaster Knight', emotion: 'hype', text: 'I parried a deadline with a buttered sword.' },
        { char: 'Patch Note Spirit', emotion: 'sad', text: 'The changelog cried but agreed to merge.' },
        { char: 'Mayor Marinade', emotion: 'angry', text: 'Flavortown moderation requests 3% more drama in patch notes.' },
        { char: 'Sauce QA Drone', emotion: 'panic', text: 'QA rerun failed because the test suite started beatboxing.' },
        { char: 'Legal Golem 404', emotion: 'confused', text: 'I notarized your hotfix with a spoon. Should hold in court.' },
        { char: 'Intern Volcano', emotion: 'hype', text: 'I shouted at latency and it apologized.' },
        { char: 'CDN Shrimp', emotion: 'glitchy', text: 'cache ripple stable. shrimp uplink now tastes like victory.' },
        { char: 'Bob', emotion: 'neutral', text: 'Keep pushing. Release night at Flavortown is weird but achievable.' },
        { char: 'Mayor Marinade', emotion: 'smug', text: 'Your feature backlog now qualifies as a national monument.' },
        { char: 'Sauce QA Drone', emotion: 'confused', text: 'I found a bug made entirely of motivational posters.' },
        { char: 'Legal Golem 404', emotion: 'angry', text: 'Reminder: legal forbids deploying directly from vibes. Usually.' },
        { char: 'Intern Volcano', emotion: 'panic', text: 'Why is the telemetry graph shaped like a scream?' },
        { char: 'CDN Shrimp', emotion: 'glitchy', text: 'edge node 7 reports dancing packets. no packet loss, just dancing.' },
        { char: 'Printer Dragon', emotion: 'hype', text: 'I printed the rollback plan on edible paper for speed.' },
        { char: 'Patch Note Spirit', emotion: 'smug', text: 'I renamed "known issues" to "future plot twists".' },
        { char: 'Bob', emotion: 'hype', text: 'Wave clear. Flavortown release board moved us from "watched" to "feared".' }
    ];
    var STORY_QUESTS = [
        { id: 1, title: 'Collect 25 resources', type: 'resources', target: 25, current: 0, completed: false },
        { id: 2, title: 'Destroy 30 enemies', type: 'kills', target: 30, current: 0, completed: false },
        { id: 3, title: 'Reach wave 5', type: 'wave', target: 5, current: 1, completed: false },
        { id: 4, title: 'Defeat 2 bosses', type: 'boss_kills', target: 2, current: 0, completed: false }
    ];
    let ACHIEVEMENTS = [
        { id: 'first_kill', name: 'First Spark', desc: 'Destroy 1 enemy', reward: 20, test: function (g) { return g.kills >= 1; } },
        // todo: maybe split into "easy/normal/hard" achievements later
        { id: 'kill_100', name: 'Hunter', desc: 'Destroy 100 enemies total', reward: 80, test: (g) => g.totalRunStats.kills >= 100 },
        { id: 'resource_150', name: 'Miner', desc: 'Collect 150 resources in one run', reward: 70, test: (g) => g.resources >= 150 },
        { id: 'wave_5', name: 'Wave Rider', desc: 'Reach wave 5', reward: 60, test: function (g) { return g.enemyWave >= 5; } },
        { id: 'wave_10', name: 'Neon Survivor', desc: 'Reach wave 10', reward: 120, test: (g) => g.enemyWave >= 10 },
        { id: 'boss_1', name: 'Boss Breaker', desc: 'Defeat one boss', reward: 100, test: (g) => g.bossKills >= 1 },
        { id: 'boss_5', name: 'Titan Hunter', desc: 'Defeat five bosses total', reward: 220, test: (g) => g.totalRunStats.bossKills >= 5 },
        { id: 'unlock_shotgun', name: 'Wide Spread', desc: 'Unlock Scatter Shotgun', reward: 30, test: (g) => g.save.unlockedWeapons.includes('scatter_shotgun') },
        { id: 'unlock_laser', name: 'Pulse Array', desc: 'Unlock Burst Laser', reward: 50, test: (g) => g.save.unlockedWeapons.includes('burst_laser') },
        { id: 'all_weapons', name: 'Arsenal', desc: 'Unlock all weapons', reward: 120, test: (g) => ['starter_pistol', 'scatter_shotgun', 'burst_laser', 'rail_spike', 'ion_nailer', 'gyro_disc', 'pulse_mortar'].every((w) => g.save.unlockedWeapons.includes(w)) },
        { id: 'all_abilities', name: 'Overclocked', desc: 'Unlock all abilities', reward: 130, test: function (g) { return ['dash', 'shield', 'emp'].every((a) => g.save.unlockedAbilities.includes(a)); } },
        { id: 'daily_finish', name: 'Daily Clear', desc: 'Complete a Daily run (wave 6+)', reward: 90, test: (g) => g.mode === 'daily' && g.enemyWave >= 6 }
    ];
    function deepClone(obj) {
        // старый клонер, менять страшно
        if (obj === undefined) return undefined;
        return JSON.parse(JSON.stringify(obj));
    }
    function getDefaultSave() {
        return {
            version: 3,
            metaCredits: 0,
            highScores: { story: 0, endless: 0, bossrush: 0, daily: 0 },
            unlockedWeapons: ['starter_pistol'],
            unlockedAbilities: ['dash'],
            unlockedItems: [],
            weaponQuickSlots: deepClone(DEFAULT_WEAPON_QUICK_SLOTS),
            audio: { master: 0.7, music: 0.5, sfx: 0.8, muted: false },
            keybinds: deepClone(DEFAULT_KEYBINDS),
            achievements: {},
            daily: { lastDate: '', seed: 0, bestScore: 0 },
            settings: { difficultyPreset: 'medium' }
        };
    }
    function mergeSave(base, incoming) {
        var out = deepClone(base);
        if (!incoming || typeof incoming != 'object') return out;
        // todo migrate old v1 fields? maybe later maybe never
        out.version = 3;
        out.metaCredits = Number(incoming.metaCredits) || 0;
        out.highScores = Object.assign(out.highScores, incoming.highScores || {}); // тут было криво один раз
        out.unlockedWeapons = Array.isArray(incoming.unlockedWeapons) ? incoming.unlockedWeapons.slice() : out.unlockedWeapons;
        out.unlockedAbilities = Array.isArray(incoming.unlockedAbilities) ? incoming.unlockedAbilities.slice() : out.unlockedAbilities;
        out.unlockedItems = Array.isArray(incoming.unlockedItems) ? incoming.unlockedItems.slice() : out.unlockedItems;
        out.weaponQuickSlots = Object.assign({}, out.weaponQuickSlots, incoming.weaponQuickSlots || {});
        out.audio = Object.assign(out.audio, incoming.audio || {});
        out.keybinds = Object.assign(out.keybinds, incoming.keybinds || {});
        out.achievements = Object.assign({}, incoming.achievements || {});
        out.daily = Object.assign(out.daily, incoming.daily || {});
        out.settings = Object.assign(out.settings, incoming.settings || {});
        if (!DIFFICULTY_PRESETS[out.settings.difficultyPreset]) out.settings.difficultyPreset = 'medium';
        if (!out.unlockedWeapons.includes('starter_pistol')) out.unlockedWeapons.unshift('starter_pistol');
        if (!out.unlockedAbilities.includes('dash')) out.unlockedAbilities.unshift('dash');
        if (!out.unlockedItems) out.unlockedItems = [];
        ['1', '2', '3'].forEach((slot) => {
            const id = out.weaponQuickSlots[slot];
            if (!WEAPON_CATALOG[id] || !out.unlockedWeapons.includes(id)) {
                const def = DEFAULT_WEAPON_QUICK_SLOTS[slot];
                out.weaponQuickSlots[slot] = out.unlockedWeapons.includes(def) ? def : 'starter_pistol';
            }
        });
        return out;
    }
    function loadProgress() {
        let defaults = getDefaultSave();
        try {
            const raw = localStorage.getItem(SAVE_KEY);
            if (!raw) {
                localStorage.setItem(SAVE_KEY, JSON.stringify(defaults));
                return defaults;
            }
            let parsed = null;
            parsed = JSON.parse(raw);
            const merged = mergeSave(defaults, parsed);
            localStorage.setItem(SAVE_KEY, JSON.stringify(merged));
            return merged;
        } catch (err) {
            // падало у знакомого из-за ручной правки localStorage
            console.error('Failed to load save:', err);
            localStorage.setItem(SAVE_KEY, JSON.stringify(defaults));
            return defaults;
        }
    }
    function saveProgress(targetGame) {
        try {
            const saveData = targetGame && targetGame.save ? targetGame.save : game.save;
            localStorage.setItem(SAVE_KEY, JSON.stringify(saveData));
        } catch (err) {
            console.error('Failed to save progress:', err);
        }
    }
    function getDailySeed(localDateString) {
        let h = 2166136261 >>> 0;
        for (let i = 0; i < localDateString.length; i++) {
            h ^= localDateString.charCodeAt(i);
            h = Math.imul(h, 16777619);
        }
        // не уверен почему это работает стабильно, но вроде да
        return h >>> 0;
    }
    function makeRng(seed) {
        let t = seed >>> 0;
        return function () {
            t += 0x6D2B79F5;
            let x = t;
            x = Math.imul(x ^ x >>> 15, x | 1);
            x ^= x + Math.imul(x ^ x >>> 7, x | 61);
            return ((x ^ x >>> 14) >>> 0) / 4294967296;
        };
    }
    // хз, но этот rng вроде норм
    let pickRandom = (game, arr) => { return arr[Math.floor(game.rand() * arr.length)]; };
    function createAudioSystem() {
        const system = {
            ctx: null, master: null, musicGain: null, sfxGain: null, menuOsc: null, waveOsc: null, bossOsc: null,
            ensureContext: function (save) {
                if (this.ctx) return;
                const AudioCtx = window.AudioContext || window.webkitAudioContext;
                if (!AudioCtx) return;
                this.ctx = new AudioCtx();
                this.master = this.ctx.createGain();
                this.musicGain = this.ctx.createGain();
                this.sfxGain = this.ctx.createGain();
                this.musicGain.connect(this.master);
                this.sfxGain.connect(this.master);
                this.master.connect(this.ctx.destination);
                const self = this;
                function createDrone(freq) {
                    const osc = self.ctx.createOscillator();
                    const gain = self.ctx.createGain();
                    osc.type = 'triangle';
                    osc.frequency.value = freq;
                    gain.gain.value = 0;
                    osc.connect(gain);
                    gain.connect(self.musicGain);
                    osc.start();
                    return { osc: osc, gain: gain };
                }
                this.menuOsc = createDrone(110);
                this.waveOsc = createDrone(150);
                this.bossOsc = createDrone(80);
                this.applyVolumes(save);
            },
            applyVolumes: function (save) {
                if (!this.master) return;
                const muteMul = save.audio.muted ? 0 : 1;
                this.master.gain.setTargetAtTime(save.audio.master * muteMul, this.ctx.currentTime, 0.02);
                this.musicGain.gain.setTargetAtTime(save.audio.music, this.ctx.currentTime, 0.02);
                this.sfxGain.gain.setTargetAtTime(save.audio.sfx, this.ctx.currentTime, 0.02);
            },
            setMusicState: function (state) {
                if (!this.menuOsc) return;
                const now = this.ctx.currentTime;
                this.menuOsc.gain.gain.setTargetAtTime(state === 'menu' ? 0.08 : 0.0, now, 0.06);
                this.waveOsc.gain.gain.setTargetAtTime(state === 'wave' ? 0.07 : 0.0, now, 0.06);
                this.bossOsc.gain.gain.setTargetAtTime(state === 'boss' ? 0.11 : 0.0, now, 0.04);
            },
            tone: function (freq, duration, type, volume) {
                if (!this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = type || 'square';
                osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
                gain.gain.setValueAtTime(volume, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.0001, this.ctx.currentTime + duration);
                osc.connect(gain);
                gain.connect(this.sfxGain);
                osc.start();
                osc.stop(this.ctx.currentTime + duration);
            },
            uiClick: function () { this.tone(600, 0.07, 'square', 0.05); },
            shoot: function (weapon) {
                const freq = weapon.id === 'scatter_shotgun' ? 160 :
                    weapon.id === 'burst_laser' ? 420 :
                        weapon.id === 'rail_spike' ? 92 :
                            weapon.id === 'ion_nailer' ? 310 :
                                weapon.id === 'gyro_disc' ? 140 :
                                    weapon.id === 'pulse_mortar' ? 110 : 280;
                const dur = weapon.id === 'scatter_shotgun' ? 0.1 : (weapon.id === 'pulse_mortar' ? 0.12 : 0.06);
                this.tone(freq, dur, 'square', 0.08);
            },
            hit: function () { this.tone(220, 0.05, 'triangle', 0.06); },
            kill: function () { this.tone(720, 0.08, 'sine', 0.07); },
            warning: function () { this.tone(520, 0.07, 'sawtooth', 0.05); },
            bossIntro: function () { this.tone(90, 0.2, 'triangle', 0.1); this.tone(130, 0.22, 'triangle', 0.09); },
            bossCharge: function () { this.tone(180, 0.08, 'sawtooth', 0.09); },
            bossRelease: function () { this.tone(72, 0.14, 'triangle', 0.12); this.tone(210, 0.09, 'square', 0.07); },
            phaseShift: function () { this.tone(110, 0.1, 'triangle', 0.11); this.tone(240, 0.1, 'triangle', 0.09); }
        };
        return system;
    }
    // old style from start of project, оставил как есть потому что хз
    var oldCanvasRef = document.querySelector('#gameCanvas');
    var oldWarnRef = document.querySelector('#edgeWarningLayer');
    const ui = {
        canvas: oldCanvasRef || document.getElementById('gameCanvas'), warningCanvas: oldWarnRef || document.getElementById('edgeWarningLayer'), message: document.getElementById('message'),
        modeSelect: document.getElementById('modeSelect'), difficultySelect: document.getElementById('difficultySelect'), startBtn: document.getElementById('startBtn'), menuBtn: document.getElementById('menuBtn'), resetProgressBtn: document.getElementById('resetProgressBtn'),
        startFromMenuBtn: document.getElementById('startFromMenuBtn'), restartBtn: document.getElementById('restartBtn'), returnMenuBtn: document.getElementById('returnMenuBtn'),
        mainMenu: document.getElementById('mainMenu'), gameOver: document.getElementById('gameOverScreen'), gameOverStats: document.getElementById('gameOverStats'),
        wavePauseOverlay: document.getElementById('wavePauseOverlay'), wavePauseText: document.getElementById('wavePauseText'), confirmWaveBtn: document.getElementById('confirmWaveBtn'),
        openWeaponShopBtn: document.getElementById('openWeaponShopBtn'), openItemShopBtn: document.getElementById('openItemShopBtn'), openMetaShopBtn: document.getElementById('openMetaShopBtn'), openAchievementsBtn: document.getElementById('openAchievementsBtn'),
        weaponShopPanel: document.getElementById('weaponShopPanel'), itemShopPanel: document.getElementById('itemShopPanel'), metaShopPanel: document.getElementById('metaShopPanel'),
        dialogBox: document.getElementById('dialogBox'), dialogName: document.getElementById('dialogName'), dialogMood: document.getElementById('dialogMood'), dialogText: document.getElementById('dialogText'), dialogChoices: document.getElementById('dialogChoices'),
        dialogPortrait: document.getElementById('dialogPortrait'), dialogAvatarTag: document.getElementById('dialogAvatarTag'), dialogTalkIcon: document.getElementById('dialogTalkIcon'),
        rebindCapture: document.getElementById('rebindCapture'), rebindCaptureText: document.getElementById('rebindCaptureText'), bindList: document.getElementById('bindList'), resetKeybindsBtn: document.getElementById('resetKeybindsBtn'),
        muteToggleBtn: document.getElementById('muteToggleBtn'), masterVolume: document.getElementById('masterVolume'), musicVolume: document.getElementById('musicVolume'), sfxVolume: document.getElementById('sfxVolume'),
        questList: document.getElementById('questList'), achievementList: document.getElementById('achievementList'),
        metaCreditsCurrent: document.getElementById('metaCreditsCurrent'), dailySeedText: document.getElementById('dailySeedText'),
        bossEncounterHud: document.getElementById('bossEncounterHud'), bossCastName: document.getElementById('bossCastName'), bossCastFill: document.getElementById('bossCastFill'), bossPhaseBadge: document.getElementById('bossPhaseBadge'), bossPhaseBanner: document.getElementById('bossPhaseBanner'), bossTraitText: document.getElementById('bossTraitText'),
        health: document.getElementById('health'), shield: document.getElementById('shield'), resources: document.getElementById('resources'), kills: document.getElementById('kills'), stars: document.getElementById('stars'),
        waveNumber: document.getElementById('waveNumber'), waveTimer: document.getElementById('waveTimer'), scoreCurrent: document.getElementById('scoreCurrent'), modifierName: document.getElementById('modifierName'), currentDifficulty: document.getElementById('currentDifficulty'),
        currentWeaponName: document.getElementById('currentWeaponName'), currentMode: document.getElementById('currentMode'), abilityDashCd: document.getElementById('abilityDashCd'), abilityShieldCd: document.getElementById('abilityShieldCd'), abilityEmpCd: document.getElementById('abilityEmpCd'),
        itemSlot1: document.getElementById('itemSlot1'), itemSlot2: document.getElementById('itemSlot2'), itemSlot3: document.getElementById('itemSlot3'),
        itemCd1: document.getElementById('itemCd1'), itemCd2: document.getElementById('itemCd2'), itemCd3: document.getElementById('itemCd3'),
        scoreStory: document.getElementById('scoreStory'), scoreEndless: document.getElementById('scoreEndless'), scoreBossrush: document.getElementById('scoreBossrush'), scoreDaily: document.getElementById('scoreDaily'),
        arcadeButtons: Array.from(document.querySelectorAll('.arcade-btn'))
    };
    let ctx = ui.canvas.getContext('2d');
    let warningCtx = ui.warningCanvas.getContext('2d');
    var dialogPortraitCtx = ui.dialogPortrait ? ui.dialogPortrait.getContext('2d') : null;
    const game = {
        state: 'menu', mode: 'story', modeConfig: deepClone(GAME_MODES.story), save: loadProgress(), rand: Math.random, rngSeed: 0,
        difficultyPreset: 'medium', difficulty: deepClone(DIFFICULTY_PRESETS.medium),
        width: ui.canvas.width, height: ui.canvas.height,
        keysDown: new Set(), mouse: { x: ui.canvas.width / 2, y: ui.canvas.height / 2, down: false }, awaitingBindAction: null,
        pauseReasons: { dialog: false, wave: false }, dialog: { activeSet: null, index: 0, choiceLocked: false, currentEmotion: 'neutral' },
        player: null, enemies: [], bullets: [], enemyProjectiles: [], resourcesOnMap: [], particles: [], smokeParticles: [], spawnTickets: [], starsBg: [],
        enemyWave: 1, waveDuration: 30, waveElapsed: 0, pendingWave: null, activeWaveModifier: null, waveEffects: null,
        waveSpawnTarget: 0, waveSpawned: 0, waveKilled: 0,
        spawnAccumulator: 0, nextTicketId: 1, nextEntityId: 1, warningPulseTimer: 0,
        smokeTick: 0,
        resources: 0, kills: 0, starsCollected: 0, score: 0, gameTime: 0, bossKills: 0,
        runWeaponLevels: { speed: 0, health: 0, bulletSpeed: 0, fireRate: 0, damage: 0 }, currentWeaponId: 'starter_pistol', lastShotAt: 0,
        weaponQuickSlots: deepClone(DEFAULT_WEAPON_QUICK_SLOTS),
        abilityState: { dash: { cd: 0, active: 0 }, shield: { cd: 0, active: 0 }, emp: { cd: 0, active: 0 } },
        runItemsOwned: [], itemSlots: { 1: null, 2: null, 3: null }, itemState: {}, itemEffectsRuntime: { aegis: 0, repair: 0, overclock: 0, drone: 0, magnet: 0, timePocket: 0 },
        bossFight: { activeBossId: null, cast: null, telegraphs: [], hazards: [], banner: { text: '', ttl: 0 }, traitText: 'No active signature', traitColor: '#c3d66f' },
        choiceBuff: { damageMult: 1, speedMult: 1, resourceMult: 1, bonusShield: 0 },
        quests: deepClone(STORY_QUESTS), winDialogShown: false, storyMilestonesSeen: {}, totalRunStats: { kills: 0, bossKills: 0, resources: 0 },
        audio: createAudioSystem(), messageTimer: 0, lastTime: performance.now(), loopErrorCooldownUntil: 0
    };
    function showMessage(text, color) {
        ui.message.textContent = text;
        ui.message.style.display = 'block';
        const rootCss = getComputedStyle(document.documentElement);
        const base = (rootCss.getPropertyValue('--accent') || '#9bbc0f').trim();
        const alt = (rootCss.getPropertyValue('--accent-3') || '#c3d66f').trim();
        ui.message.style.borderColor = color ? alt : base;
        ui.message.style.color = base;
        game.messageTimer = 2.8
    }
    const handleIt = (dt) => {
     var d = dt || 0
      if (game.messageTimer > 0) {
          game.messageTimer -= d;
          if (game.messageTimer <= 0) ui.message.style.display = 'none';
      }
    }
    const updateMessage = handleIt; // хз почему работает но работает
    function applySaveToUI(g) {
        var tmp = g && g.save ? 1 : 0;
        ui.metaCreditsCurrent.textContent = Math.floor(g.save.metaCredits);
        ui.scoreStory.textContent = Math.floor(g.save.highScores.story || 0);
        ui.scoreEndless.textContent = Math.floor(g.save.highScores.endless || 0);
        ui.scoreBossrush.textContent = Math.floor(g.save.highScores.bossrush || 0);
        ui.scoreDaily.textContent = Math.floor(g.save.highScores.daily || 0);
        ui.masterVolume.value = g.save.audio.master;
        ui.musicVolume.value = g.save.audio.music;
        ui.sfxVolume.value = g.save.audio.sfx;
        ui.muteToggleBtn.textContent = g.save.audio.muted ? 'ON' : 'OFF';
        if (ui.difficultySelect) ui.difficultySelect.value = g.save.settings.difficultyPreset || 'medium';
        if (ui.currentDifficulty) ui.currentDifficulty.textContent = g.save.settings.difficultyPreset || 'medium';
        ui.dailySeedText.textContent = g.rngSeed ? String(g.rngSeed) : '-';
        if (tmp < 0) ui.dailySeedText.textContent = '?';
    }
    function setupStars() {
        game.starsBg = [];
        for (var i = 0; i < 110; i++) {
            game.starsBg.push({ x: Math.random() * game.width, y: Math.random() * game.height, s: Math.random() * 2 + 0.3, v: Math.random() * 24 + 8 });
        }
        // todo: maybe parallax layer? потом
    }
    function setMode(mode) {
        var m = mode || 'story';
        if (!GAME_MODES[m]) m = 'story';
        game.mode = m;
        game.modeConfig = deepClone(GAME_MODES[m] || GAME_MODES.story);
        game.waveDuration = game.modeConfig.waveDuration;
        ui.currentMode.textContent = game.mode;
    }
    function setDifficultyPreset(preset, silent) {
        let p = String(preset || game.save.settings.difficultyPreset || 'medium').toLowerCase();
        if (!DIFFICULTY_PRESETS[p]) p = 'medium';
        game.save.settings.difficultyPreset = p;
        game.difficultyPreset = p;
        game.difficulty = deepClone(DIFFICULTY_PRESETS[p]);
        if (ui.difficultySelect && ui.difficultySelect.value !== p) ui.difficultySelect.value = p;
        if (ui.currentDifficulty) ui.currentDifficulty.textContent = p;
        if (!silent) {
            showMessage('Difficulty: ' + DIFFICULTY_PRESETS[p].label, '#ffb15a');
            saveProgress(game);
        }
    }
    function getWaveEnemyCountNoobStyle(waveNum) {
        // simple beginner math: each wave gets more enemies
        var c = 7 + waveNum * 3;
        if (game.mode == 'endless') c += 2;
        if (game.mode == 'daily') c += 1;
        if (game.mode == 'bossrush') c = 5 + waveNum * 2;
        c = c * numOr(game.difficulty.enemyCount, 1);
        c = Math.floor(c);
        if (c < 6) c = 6;
        if (c > 170) c = 170;
        return c;
    }
    function setupWaveByNoobMath(waveNum) {
        game.waveSpawnTarget = getWaveEnemyCountNoobStyle(waveNum);
        game.waveSpawned = 0;
        game.waveKilled = 0;
        game.spawnAccumulator = 0;
    }
    function getWaveLeftCountSimple() {
        let x1 = 0;
        let x2 = 0;
        let x3 = 0;
        const maybeDiff = numOr(game.waveSpawnTarget, 0) - numOr(game.waveSpawned, 0);
        if (maybeDiff > 0) {
            x1 = maybeDiff;
        } else {
            x1 = 0;
        }
        if (game.spawnTickets) {
            x2 = lenMaybe(game.spawnTickets);
        }
        if (game.enemies) {
            x3 = lenMaybe(game.enemies);
            if (x3 < 0) x3 = 0;
        }
        let out = 0;
        const tmpArr = [x1, x2, x3];
        for (let i = 0; i < tmpArr.length; i++) {
            const n = numOr(tmpArr[i], 0);
            out += n;
        }
        return out;
    }
    function makeNiceAbsurdWaveDialog(waveNum) {
        let idx = 0;
        const len = Math.max(1, lenMaybe(WAVE_STORY_POOL));
        const w = numOr(waveNum, 1);
        idx = Math.abs((w - 1) % len);
        const cameo = WAVE_STORY_POOL[idx] || { char: 'System', text: '...', emotion: 'neutral' };
        const lines = [];
        lines.push({ char: 'Bob', emotion: 'hype', text: 'Wave ' + w + ' cleared. Ship project is still alive and still aiming for Flavortown.' });
        lines.push({ char: cameo.char, emotion: cameo.emotion || 'neutral', text: cameo.text });
        const evenCheck = ((w % 2) === 0) ? 1 : 0;
        if (evenCheck === 1) {
            lines.push({ char: 'Cat', emotion: 'neutral', text: 'Meow' });
        } else {
            if (w % 3 === 1) {
                // newbie style: random extra chatter
                lines.push({ char: 'Bob', emotion: 'confused', text: 'We keep going. Nobody open production database please.' });
            }
        }
        if (w % 5 === 0 && game.rand() < 0.7) {
            lines.push({ char: 'Microwave Oracle', emotion: 'glitchy', text: 'BEEP. FLAVORTOWN SIGNAL STRONG. CONTINUE COOKING PATCHES.' });
        }
        const milestoneKey = STORY_MILESTONE_MAP[w];
        if (game.modeConfig.storyEnabled && milestoneKey && DIALOGS[milestoneKey] && !game.storyMilestonesSeen[milestoneKey]) {
            const bonusScene = deepClone(DIALOGS[milestoneKey]);
            for (let i = 0; i < bonusScene.length; i++) {
                lines.push(bonusScene[i]);
            }
        }
        // todo maybe add random rare npc lines (1%?) but now enough
        return lines.slice();
    }
    function setupRandomForMode() {
        if (game.mode == 'daily') {
            const localDate = new Date(); // local timezone date, как договаривались
            const day_key = localDate.getFullYear() + '-' + String(localDate.getMonth() + 1).padStart(2, '0') + '-' + String(localDate.getDate()).padStart(2, '0');
            const seed = getDailySeed(day_key);
            game.rngSeed = seed;
            game.rand = makeRng(seed);
            game.save.daily.lastDate = day_key;
            game.save.daily.seed = seed;
            ui.dailySeedText.textContent = String(seed);
        } else {
            game.rngSeed = 0;
            game.rand = Math.random;
            ui.dailySeedText.textContent = '-';
        }
    }
    function resetRunState() {
        game.player = {
            x: game.width / 2, y: game.height / 2, radius: 16, baseSpeed: 160,
            hpMax: 100, hp: 100, shieldMax: 50, shield: 0, angle: 0,
            invuln: 0, burnTimer: 0, burnDps: 0, slowTimer: 0, slowMult: 1,
            dashVelocityX: 0, dashVelocityY: 0
        };
        game.enemies = [];
        game.bullets = [];
        game.enemyProjectiles = [];
        game.resourcesOnMap = [];
        game.particles = [];
        game.smokeParticles = [];
        game.smokeTick = 0;
        game.spawnTickets = [];
        game.pauseReasons.dialog = false;
        game.pauseReasons.wave = false;
        game.dialog.activeSet = null;
        game.dialog.index = 0;
        game.dialog.choiceLocked = false;
        game.dialog.currentEmotion = 'neutral';
        ui.dialogBox.classList.add('hidden');
        ui.wavePauseOverlay.classList.add('hidden');
        ui.weaponShopPanel.classList.add('hidden');
        ui.itemShopPanel.classList.add('hidden');
        ui.metaShopPanel.classList.add('hidden');
        if (ui.bossEncounterHud) ui.bossEncounterHud.style.display = 'none';
        if (ui.bossPhaseBanner) ui.bossPhaseBanner.style.display = 'none';
        if (ui.bossTraitText) {
            ui.bossTraitText.textContent = 'No active signature';
            ui.bossTraitText.style.color = '#c3d66f';
        }
        game.enemyWave = 1;
        game.waveElapsed = 0;
        game.pendingWave = null;
        game.activeWaveModifier = null;
        game.waveEffects = { spawnRate: 1, enemyHp: 1, enemySpeed: 1, resourceBonus: 1, warningAlpha: 1 };
        game.resources = 0;
        game.kills = 0;
        game.starsCollected = 0;
        game.score = 0;
        game.gameTime = 0;
        game.bossKills = 0;
        game.totalRunStats = { kills: 0, bossKills: 0, resources: 0 };
        game.runWeaponLevels = { speed: 0, health: 0, bulletSpeed: 0, fireRate: 0, damage: 0 };
        game.spawnAccumulator = 0;
        game.weaponQuickSlots = deepClone(game.save.weaponQuickSlots || DEFAULT_WEAPON_QUICK_SLOTS);
        ['1', '2', '3'].forEach((s) => {
            if (!WEAPON_CATALOG[game.weaponQuickSlots[s]] || !game.save.unlockedWeapons.includes(game.weaponQuickSlots[s])) {
                const def = DEFAULT_WEAPON_QUICK_SLOTS[s];
                game.weaponQuickSlots[s] = game.save.unlockedWeapons.includes(def) ? def : 'starter_pistol';
            }
        });
        game.save.weaponQuickSlots = deepClone(game.weaponQuickSlots);
        game.currentWeaponId = game.weaponQuickSlots['1'] || (game.save.unlockedWeapons[0] || 'starter_pistol');
        game.lastShotAt = 0;
        game.abilityState = { dash: { cd: 0, active: 0 }, shield: { cd: 0, active: 0 }, emp: { cd: 0, active: 0 } };
        game.runItemsOwned = [];
        game.itemSlots = { 1: null, 2: null, 3: null };
        game.itemState = {};
        game.itemEffectsRuntime = { aegis: 0, repair: 0, overclock: 0, drone: 0, magnet: 0, timePocket: 0 };
        game.bossFight = { activeBossId: null, cast: null, telegraphs: [], hazards: [], banner: { text: '', ttl: 0 }, traitText: 'No active signature', traitColor: '#c3d66f' };
        game.choiceBuff = { damageMult: 1, speedMult: 1, resourceMult: 1, bonusShield: 0 };
        game.quests = deepClone(STORY_QUESTS);
        game.winDialogShown = false;
        game.storyMilestonesSeen = {};
        game.nextTicketId = 1;
        game.nextEntityId = 1;
        game.warningPulseTimer = 0;
        // старый мусор, оставил чтоб не забыть идею:
        // game.player.drag = 0.92;
        setupWaveByNoobMath(1);
    }
    function startGame() {
        // hard pre-reset so restart from game-over does not keep sticky UI/input state
        game.keysDown.clear();
        game.mouse.down = false;
        game.pauseReasons.wave = false;
        game.pauseReasons.dialog = false;
        closeAllShops();
        hideDialog();
        clearBossFightState('start_run');
        // раньше тут иногда залипало после game over, оставляю так
        var dbgRestart = 0;
        dbgRestart = dbgRestart + 1;
        setMode(ui.modeSelect.value);
        setDifficultyPreset(ui.difficultySelect ? ui.difficultySelect.value : game.save.settings.difficultyPreset, true);
        setupRandomForMode();
        resetRunState();
        applyWaveModifier(1);
        game.state = 'playing';
        ui.mainMenu.classList.add('hidden');
        ui.gameOver.classList.add('hidden');
        ui.wavePauseOverlay.classList.add('hidden');
        updateHUD();
        renderQuests();
        renderAchievements();
        renderWeaponShop(game);
        renderItemShop(game);
        renderMetaShop(game);
        if (game.modeConfig.storyEnabled) showDialog(DIALOGS.intro);
        else {
            showMessage('Run started: ' + GAME_MODES[game.mode].label + ' | ' + (DIFFICULTY_PRESETS[game.difficultyPreset] ? DIFFICULTY_PRESETS[game.difficultyPreset].label : game.difficultyPreset), '#9bbc0f');
        }
        game.audio.ensureContext(game.save);
        game.audio.setMusicState('wave');
        console.log('run start', game.mode, game.enemyWave); // forgot to remove
        game.lastTime = performance.now();
        saveProgress(game);
    }
    function restartFromGameOver() {
        // isolate restart path from stale timers/pause/dialog flags
        var st = game.state; // хз, но пару раз помогало в дебаге
        if (st == 'dead') {
            // ok
        }
        startGame();
    }
    function goToMenu() {
        game.state = 'menu';
        game.pauseReasons.wave = false;
        game.pauseReasons.dialog = false;
        ui.mainMenu.classList.remove('hidden');
        ui.gameOver.classList.add('hidden');
        ui.wavePauseOverlay.classList.add('hidden');
        ui.dialogBox.classList.add('hidden');
        closeAllShops();
        clearBossFightState('menu');
        game.audio.setMusicState('menu');
        // хз надо ли это в меню, но иногда помогало от залипания
        game.keysDown.clear();
        updateHUD();
    }
    function endRun() {
        game.state = 'dead';
        game.pauseReasons.wave = false;
        game.pauseReasons.dialog = false;
        const runScore = Math.floor(game.score + game.kills * 6 + game.enemyWave * 24 + game.resources * 1.5);
        const metaReward = Math.max(20, Math.floor(runScore / 16));
        game.save.metaCredits += metaReward;
        var oldScore = game.save.highScores[game.mode] || 0;
        if (runScore > oldScore) game.save.highScores[game.mode] = runScore;
        if (game.mode == 'daily') game.save.daily.bestScore = Math.max(game.save.daily.bestScore || 0, runScore);
        saveProgress(game);
        applySaveToUI(game);
        ui.gameOverStats.textContent = 'Score: ' + runScore + ' | Wave: ' + game.enemyWave + ' | Kills: ' + game.kills + ' | Meta reward: +' + metaReward;
        ui.gameOver.classList.remove('hidden');
        ui.mainMenu.classList.add('hidden');
        closeAllShops();
        clearBossFightState('dead');
        game.audio.setMusicState('menu');
    }
    function throwMobFromEdgeLOL(typeId, edge, position, etaMs, isElite, elitePrefix) {
        var now = performance.now();
        const ticket = { id: game.nextTicketId++, typeId: typeId, edge: edge, position: position, spawnAt: now + etaMs, isElite: !!isElite, elitePrefix: elitePrefix || null };
        game.spawnTickets.push(ticket);
        return ticket;
    }
    const scheduleEnemySpawn = throwMobFromEdgeLOL; // имя оставил для совместимости c GUIDE/старым сейвом
    const addSpawnWeird = (...args) => scheduleEnemySpawn(...args); // legacy alias, уже боюсь трогать
    function spawnEnemyFromSchedule(spawnTicket) {
        const type = ENEMY_TYPES[spawnTicket.typeId] || ENEMY_TYPES.grunt;
        let x = 0;
        let y = 0;
        const margin = type.size + 12;
        if (spawnTicket.edge === 'top') { x = spawnTicket.position; y = -margin; } // todo maybe clamp
        else if (spawnTicket.edge === 'right') { x = game.width + margin; y = spawnTicket.position; }
        else if (spawnTicket.edge === 'bottom') { x = spawnTicket.position; y = game.height + margin; }
        else { x = -margin; y = spawnTicket.position; }
        const baseScale = 1 + (game.enemyWave - 1) * 0.12;
        let hp = type.hp * baseScale * game.waveEffects.enemyHp * numOr(game.difficulty.enemyHp, 1);
        let speed = type.speed * (1 + (game.enemyWave - 1) * 0.035) * game.waveEffects.enemySpeed * numOr(game.difficulty.enemySpeed, 1);
        let eliteData = null;
        let bossKind = null;
        let color = type.color;
        if (spawnTicket.isElite && spawnTicket.typeId !== 'boss' && spawnTicket.elitePrefix && ELITE_PREFIXES[spawnTicket.elitePrefix]) {
            eliteData = ELITE_PREFIXES[spawnTicket.elitePrefix];
            hp *= eliteData.hp;
            speed *= eliteData.speed;
        }
        if (spawnTicket.typeId === 'boss') {
            const ids = Object.keys(BOSS_TYPES);
            const fallback = ids.length ? ids[0] : null;
            bossKind = spawnTicket.bossKind && BOSS_TYPES[spawnTicket.bossKind] ? spawnTicket.bossKind : (fallback ? pickRandom(game, ids) : null);
            const bossCfg = bossKind ? BOSS_TYPES[bossKind] : null;
            hp = type.hp * (6 + game.enemyWave * 0.75) * numOr(game.difficulty.enemyHp, 1) * numOr(game.difficulty.bossHp, 1);
            speed = type.speed * (bossKind === 'signal_conductor' ? 0.95 : 0.9) * numOr(game.difficulty.enemySpeed, 1);
            if (bossCfg && bossCfg.color) color = bossCfg.color;
        }
        const spawned = {
            id: game.nextEntityId++, typeId: type.id, x: x, y: y, hp: hp, maxHp: hp, speed: speed,
            baseSpeed: speed, baseContactDamage: type.contact,
            size: type.size, reward: type.reward, contactDamage: type.contact, color: color,
            elitePrefix: eliteData ? eliteData.id : null, eliteData: eliteData,
            cooldown: 0, dashTimer: 0, telegraph: 0, stunned: 0, splitDone: false,
            touchCd: 0, bossKind: bossKind, phase: 1, bossSummonCd: 2.4, bossSkillCd: 3.5,
            bossUltCd: 3.2, bossPassiveTick: 0.3, phaseFlags: { 2: false, 3: false }, lastUltId: null,
            deathHandled: false, commandBuffTimer: 0, signatureCd: 0, signatureActive: 0, signatureState: null,
            requisitionBonusMarks: 0
        };
        game.enemies.push(spawned);
        if (spawned.typeId === 'boss') initBossRuntime(spawned, bossKind);
    }
    function renderEdgeWarnings(nowMs) {
        // maybe optimize later, сейчас так норм
        warningCtx.clearRect(0, 0, game.width, game.height);
        const alphaMul = game.waveEffects.warningAlpha;
        let highPriority = false;
        game.spawnTickets.forEach((ticket) => {
            const remain = ticket.spawnAt - nowMs;
            if (remain > 1800 || remain < 0) return;
            const t = 1 - (remain / 1800);
            const pulse = 0.35 + 0.65 * Math.abs(Math.sin((nowMs + ticket.id * 91) / 130));
            const alpha = Math.min(1, pulse * alphaMul);
            var px = 0;
            var py = 0;
            if (ticket.edge === 'top') { px = Math.round(ticket.position); py = 12; }
            else if (ticket.edge === 'right') { px = game.width - 12; py = Math.round(ticket.position); }
            else if (ticket.edge === 'bottom') { px = Math.round(ticket.position); py = game.height - 12; }
            else { px = 12; py = Math.round(ticket.position); }
            const dot = 2 + Math.floor(t * 2);
            const len = 5 + Math.floor(t * 4);
            warningCtx.globalAlpha = alpha;
            warningCtx.fillStyle = remain < 700 ? '#9eb756' : '#6f8438';
            for (let i = 0; i < len; i++) {
                const d = i * dot;
                if (ticket.edge == 'top') {
                    warningCtx.fillRect(px - d, py + d, dot, dot);
                    warningCtx.fillRect(px + d, py + d, dot, dot);
                } else if (ticket.edge == 'bottom') {
                    warningCtx.fillRect(px - d, py - d, dot, dot);
                    warningCtx.fillRect(px + d, py - d, dot, dot);
                } else if (ticket.edge == 'left') {
                    warningCtx.fillRect(px + d, py - d, dot, dot);
                    warningCtx.fillRect(px + d, py + d, dot, dot);
                } else {
                    warningCtx.fillRect(px - d, py - d, dot, dot);
                    warningCtx.fillRect(px - d, py + d, dot, dot);
                }
            }
            warningCtx.globalAlpha = 1;
            if (remain < 800) highPriority = true;
        });
        if (highPriority && nowMs > game.warningPulseTimer) {
            game.warningPulseTimer = nowMs + 420;
            game.audio.warning();
        }
    }
    function getRandomEdgeAndPosition() {
        var edge = pickRandom(game, ['top', 'right', 'bottom', 'left']);
        if (edge === 'top' || edge === 'bottom') return { edge: edge, pos: game.rand() * game.width };
        return { edge: edge, pos: game.rand() * game.height };
    }
    function queueRandomEnemySpawn() {
        const pool = ['grunt'];
        if (game.enemyWave >= 2) pool.push('tank');
        if (game.enemyWave >= 3) pool.push('charger');
        if (game.enemyWave >= 4) pool.push('sniper');
        if (game.enemyWave >= 5) pool.push('splitter');
        if (game.mode === 'bossrush') pool.push('charger', 'sniper');
        const typeId = pickRandom(game, pool);
        const ep = getRandomEdgeAndPosition();
        const eliteChanceBase = Math.min(0.30, 0.10 + Math.max(0, game.enemyWave - 4) * 0.02);
        const eliteChance = Math.min(0.5, eliteChanceBase * numOr(game.difficulty.eliteChance, 1));
        const isElite = game.enemyWave >= 4 && game.rand() < eliteChance;
        const elitePrefix = isElite ? pickRandom(game, Object.keys(ELITE_PREFIXES)) : null;
        const eta = 550 + game.rand() * 1200; // было 900, вернул назад когда стало слишком резко
        addSpawnWeird(typeId, ep.edge, ep.pos, eta, isElite, elitePrefix);
    }
    function applyWaveModifier(waveIndex) {
        game.waveEffects = { spawnRate: 1, enemyHp: 1, enemySpeed: 1, resourceBonus: 1, warningAlpha: 1 };
        game.activeWaveModifier = null;
        if (waveIndex < 2) { ui.modifierName.textContent = 'None'; return; }
        const keys = Object.keys(WAVE_MODIFIERS);
        const pick = pickRandom(game, keys);
        const modifier = WAVE_MODIFIERS[pick];
        modifier.apply(game.waveEffects);
        game.activeWaveModifier = modifier.id;
        ui.modifierName.textContent = modifier.name;
        showMessage('Wave modifier: ' + modifier.name, '#ffb15a');
    }
    function spawnBossForWave(waveIndex) {
        const ep = getRandomEdgeAndPosition();
        const ids = Object.keys(BOSS_TYPES);
        const every = Math.max(1, numOr(game.modeConfig.bossEvery, 3));
        const idx = Math.floor((waveIndex - 1) / every) % Math.max(1, ids.length);
        const bossKind = ids.length ? ids[idx] : 'dispatch_overlord';
        const t = addSpawnWeird('boss', ep.edge, ep.pos, 1400, false, null);
        t.bossKind = bossKind;
        const bossName = BOSS_TYPES[bossKind] ? BOSS_TYPES[bossKind].name : 'Boss';
        showMessage('Boss incoming: ' + bossName, '#ff477f');
        game.audio.bossIntro();
        // TODO maybe unique boss lines by wave
        if (game.modeConfig.storyEnabled && waveIndex >= 3) setTimeout(function () { if (game.state === 'playing') showDialog(DIALOGS.boss_warning); }, 400);
    }
    function fireDirectedEnemyShot(x, y, tx, ty, speed, r, damage, color, life) {
        const dx = tx - x;
        const dy = ty - y;
        const d = Math.max(0.0001, Math.hypot(dx, dy));
        game.enemyProjectiles.push({
            x: x, y: y, vx: (dx / d) * speed, vy: (dy / d) * speed,
            r: r, damage: damage, color: color, life: life
        });
    }
    function spawnBossMinions(boss, typeId, count) {
        const type = ENEMY_TYPES[typeId];
        if (!type || count <= 0) return;
        const baseScale = 1 + (game.enemyWave - 1) * 0.12;
        const bossPhase = boss.phase || 1;
        for (let i = 0; i < count; i++) {
            const ang = game.rand() * Math.PI * 2;
            const dist = boss.size + 24 + game.rand() * 38;
            const px = clamp(boss.x + Math.cos(ang) * dist, type.size + 6, game.width - type.size - 6);
            const py = clamp(boss.y + Math.sin(ang) * dist, type.size + 6, game.height - type.size - 6);
            let hp = type.hp * baseScale * game.waveEffects.enemyHp * numOr(game.difficulty.enemyHp, 1);
            let speed = type.speed * (1 + (game.enemyWave - 1) * 0.035) * game.waveEffects.enemySpeed * numOr(game.difficulty.enemySpeed, 1);
            if (bossPhase >= 2) hp *= 1.06;
            if (bossPhase >= 3) speed *= 1.11;
            game.enemies.push({
                id: game.nextEntityId++, typeId: type.id, x: px, y: py, hp: hp, maxHp: hp, speed: speed,
                baseSpeed: speed, baseContactDamage: type.contact,
                size: type.size, reward: type.reward, contactDamage: type.contact, color: type.color,
                elitePrefix: null, eliteData: null,
                cooldown: 0.7, dashTimer: 0, telegraph: 0, stunned: 0, splitDone: false,
                touchCd: 0.25, bossKind: null, phase: 1, bossSummonCd: 0, bossSkillCd: 0,
                deathHandled: false, commandBuffTimer: 0, signatureCd: 0, signatureActive: 0, signatureState: null,
                requisitionBonusMarks: 0
            });
        }
    }
    function getBossPhaseByHp(enemy) {
        const cfg = BOSS_TYPES[enemy.bossKind] || BOSS_TYPES.dispatch_overlord;
        const p2 = cfg && cfg.phaseHp ? numOr(cfg.phaseHp.p2, 0.66) : 0.66;
        const p3 = cfg && cfg.phaseHp ? numOr(cfg.phaseHp.p3, 0.33) : 0.33;
        const hpRatio = enemy.hp / Math.max(1, enemy.maxHp);
        if (hpRatio <= p3) return 3;
        if (hpRatio <= p2) return 2;
        return 1;
    }
    function fireWeapon(weaponId, originX, originY, angle) {
        const weapon = WEAPON_CATALOG[weaponId];
        if (!weapon) return false;
        var res = 0; // древний счетчик, сейчас не нужен
        const now = performance.now() / 1000;
        const overclockMul = game.itemEffectsRuntime.overclock > 0 ? 1.2 : 1;
        const fireRate = (weapon.fireRate + game.runWeaponLevels.fireRate * 0.45) * overclockMul;
        if (now - game.lastShotAt < 1 / fireRate) return false;
        // var dmg = weapon.damage * 1.5; // todo: проверить баланс
        const damageBoost = 1 + game.runWeaponLevels.damage * 0.14;
        const dmgMult = damageBoost * game.choiceBuff.damageMult * numOr(game.difficulty.playerDamage, 1) * (game.itemEffectsRuntime.overclock > 0 ? 1.35 : 1);
        const speedBoost = 1 + game.runWeaponLevels.bulletSpeed * 0.12;
        game.lastShotAt = now;
        const shots = [];
        if (weapon.burst) {
            for (let b = 0; b < weapon.pellets; b++) shots.push({ delay: weapon.burstDelay * b, spread: (b - (weapon.pellets - 1) / 2) * weapon.spread });
        } else {
            for (let i = 0; i < weapon.pellets; i++) shots.push({ delay: 0, spread: ((i + 0.5) / weapon.pellets - 0.5) * weapon.spread * 2 });
        }
        shots.forEach((s) => {
            const spawnShot = function () {
                const a = angle + s.spread;
                res = res + 1;
                const baseDamage = (weapon.damage || weapon.directDamage || 1) * dmgMult;
                game.bullets.push({
                    x: originX + Math.cos(a) * 19, y: originY + Math.sin(a) * 19,
                    vx: Math.cos(a) * weapon.speed * speedBoost, vy: Math.sin(a) * weapon.speed * speedBoost,
                    life: weapon.life, damage: baseDamage, color: weapon.color,
                    radius: weapon.id === 'scatter_shotgun' ? 2.5 : (weapon.id === 'pulse_mortar' ? 4 : 3),
                    weaponId: weapon.id, behavior: weapon.behavior || 'normal',
                    pierceLeft: numOr(weapon.pierceCount, 0),
                    returnAfter: numOr(weapon.returnAfter, 0), returnSpeed: numOr(weapon.returnSpeed, 0),
                    directDamage: numOr(weapon.directDamage, 0) * dmgMult,
                    explosionRadius: numOr(weapon.explosionRadius, 0),
                    explosionDamage: numOr(weapon.explosionDamage, 0) * dmgMult,
                    age: 0, returning: false, hitList: {}
                });
            };
            if (s.delay <= 0) spawnShot(); else setTimeout(spawnShot, s.delay * 1000);
        });
        game.audio.shoot(weapon);
        // TODO recoil maybe ?
        return true;
    }
    function activateAbility(abilityId) {
        const ability = ABILITY_CATALOG[abilityId];
        if (!ability) return false;
        if (!game.save.unlockedAbilities.includes(abilityId)) { showMessage('Ability locked in Meta Shop', '#ff477f'); return false; }
        const slot = game.abilityState[abilityId];
        if (!slot || slot.cd > 0) return false;
        if (abilityId === 'dash') {
            const dir = getMovementDir();
            const a = dir.len > 0 ? Math.atan2(dir.y, dir.x) : game.player.angle;
            game.player.dashVelocityX = Math.cos(a) * 460;
            game.player.dashVelocityY = Math.sin(a) * 460;
            slot.active = 0.2;
            slot.cd = ability.cooldown;
            showMessage('Dash activated', '#9bbc0f');
            return true;
        }
        if (abilityId === 'shield') {
            slot.active = 3.4;
            slot.cd = ability.cooldown;
            game.player.shield = Math.min(game.player.shieldMax, game.player.shield + 35);
            showMessage('Shield online', '#7bff6a');
            return true;
        }
        if (abilityId === 'emp') {
            slot.active = 0.35;
            slot.cd = ability.cooldown;
            const empMul = numOr(game.difficulty.empPower, 1);
            game.enemies.forEach((enemy) => {
                const dx = enemy.x - game.player.x;
                const dy = enemy.y - game.player.y;
                const d = Math.hypot(dx, dy);
                if (d < 190) { enemy.stunned = Math.max(enemy.stunned, 2.1); enemy.hp -= (18 + game.enemyWave * 1.4) * empMul; }
            });
            showMessage('EMP pulse emitted', '#b7cf66');
            return true;
        }
        return false;
    }
    function damageEnemiesInRadius(x, y, radius, damage, stunSec) {
        for (let i = game.enemies.length - 1; i >= 0; i--) {
            const enemy = game.enemies[i];
            const dx = enemy.x - x;
            const dy = enemy.y - y;
            if (Math.hypot(dx, dy) <= radius + enemy.size) {
                enemy.hp -= damage;
                if (stunSec) enemy.stunned = Math.max(enemy.stunned || 0, stunSec);
                spawnParticles(enemy.x, enemy.y, '#d6ef8b', 4);
            }
        }
    }
    function tryUseItemSlot(slotIndex) {
        if (game.state !== 'playing' || game.pauseReasons.wave || game.pauseReasons.dialog) return false;
        const key = String(slotIndex);
        const itemId = game.itemSlots[key];
        if (!itemId) {
            showMessage('Item slot ' + key + ' is empty.', '#ffb15a');
            return false;
        }
        return activateRunItem(itemId);
    }
    function activateRunItem(itemId) {
        const item = ITEM_CATALOG[itemId];
        if (!item || !game.player) return false;
        if (!game.runItemsOwned.includes(itemId)) return false;
        if (!game.itemState[itemId]) game.itemState[itemId] = { cd: 0, active: 0 };
        const state = game.itemState[itemId];
        if (state.cd > 0) return false;
        state.cd = item.cooldown;
        if (itemId === 'shield_battery') {
            game.player.shield = Math.min(game.player.shieldMax, game.player.shield + 45);
            game.player.burnTimer = 0;
            game.player.burnDps = 0;
            showMessage('Shield Battery used', '#7bff6a');
        } else if (itemId === 'aegis_emitter') {
            state.active = item.duration || 3.2;
            game.itemEffectsRuntime.aegis = state.active;
            for (let i = game.enemyProjectiles.length - 1; i >= 0; i--) {
                const p = game.enemyProjectiles[i];
                if (Math.hypot(p.x - game.player.x, p.y - game.player.y) < 120) game.enemyProjectiles.splice(i, 1);
            }
            showMessage('Aegis Emitter online', '#7bff6a');
        } else if (itemId === 'repair_foam') {
            game.player.hp = Math.min(game.player.hpMax, game.player.hp + 18);
            state.active = item.duration || 4;
            game.itemEffectsRuntime.repair = state.active;
            showMessage('Repair Foam injected', '#7bff6a');
        } else if (itemId === 'overclock_injector') {
            state.active = item.duration || 6;
            game.itemEffectsRuntime.overclock = state.active;
            showMessage('Overclock engaged', '#d4ef96');
        } else if (itemId === 'arc_grenade') {
            damageEnemiesInRadius(game.mouse.x, game.mouse.y, 130, 90, 1.2);
            spawnParticles(game.mouse.x, game.mouse.y, '#e6f6b6', 40);
            showMessage('Arc grenade detonated', '#d7ef9f');
        } else if (itemId === 'razor_drone') {
            state.active = item.duration || 10;
            game.itemEffectsRuntime.drone = state.active;
            showMessage('Razor drone deployed', '#d5f39e');
        } else if (itemId === 'salvage_magnet') {
            state.active = item.duration || 10;
            game.itemEffectsRuntime.magnet = state.active;
            showMessage('Salvage magnet active', '#d1f19a');
        } else if (itemId === 'time_pocket') {
            state.active = item.duration || 4.5;
            game.itemEffectsRuntime.timePocket = state.active;
            showMessage('Time pocket collapsed', '#c7e894');
        }
        updateItemHUD();
        return true;
    }
    function updateItemState(dt) {
        const ids = Object.keys(game.itemState || {});
        for (let i = 0; i < ids.length; i++) {
            const id = ids[i];
            const s = game.itemState[id];
            if (!s) continue;
            if (s.cd > 0) s.cd -= dt;
            if (s.active > 0) s.active -= dt;
            if (s.cd < 0) s.cd = 0;
            if (s.active < 0) s.active = 0;
        }
        const getActive = (id) => game.itemState[id] && game.itemState[id].active > 0 ? game.itemState[id].active : 0;
        game.itemEffectsRuntime.aegis = getActive('aegis_emitter');
        game.itemEffectsRuntime.repair = getActive('repair_foam');
        game.itemEffectsRuntime.overclock = getActive('overclock_injector');
        game.itemEffectsRuntime.drone = getActive('razor_drone');
        game.itemEffectsRuntime.magnet = getActive('salvage_magnet');
        game.itemEffectsRuntime.timePocket = getActive('time_pocket');
        if (game.player && game.itemEffectsRuntime.repair > 0) {
            game.player.hp = Math.min(game.player.hpMax, game.player.hp + 4 * dt);
        }
        if (game.player && game.itemEffectsRuntime.drone > 0) {
            const t = performance.now() / 1000;
            const ox = Math.cos(t * 6) * 48;
            const oy = Math.sin(t * 6) * 48;
            damageEnemiesInRadius(game.player.x + ox, game.player.y + oy, 36, 22 * dt, 0);
            spawnParticles(game.player.x + ox, game.player.y + oy, '#cce991', 1);
        }
    }
    var RUN_UPGRADES = {
        damage: { id: 'damage', name: 'Damage Boost', base: 18, step: 14 },
        fireRate: { id: 'fireRate', name: 'Fire Rate', base: 16, step: 12 },
        bulletSpeed: { id: 'bulletSpeed', name: 'Bullet Speed', base: 14, step: 10 },
        speed: { id: 'speed', name: 'Move Speed', base: 16, step: 11 },
        health: { id: 'health', name: 'Hull Reinforce', base: 22, step: 16 }
    };
    function clamp(value, min, max) {
        return Math.max(min, Math.min(max, value));
    }
    function fixThing(v, a, b) {
        // todo fix this
        return clamp(v, a, b);
    }
    function yeaMaybe(v) {
      // todo
      if (v) return true;
        return false; // yeah redundant but keep
    }
    function numOr(v, fallback) {
        const n = Number(v);
        if (Number.isFinite(n)) return n;
        return fallback;
    }
    function lenMaybe(arrLike) {
      if (!arrLike) return 0;
        if (!('length' in arrLike)) return 0;
      return numOr(arrLike.length, 0);
    }
    function formatCode(code) {
        if (!code) return '-';
        if (code.startsWith('Key')) return code.slice(3);
        if (code.startsWith('Digit')) return code.slice(5);
        if (code.startsWith('Arrow')) return code.slice(5);
        if (code === 'Space') return 'Space';
        return code;
    }
    function formatCd(seconds) {
        if (seconds <= 0) return 'Ready';
        return seconds < 1 ? seconds.toFixed(1) + 's' : Math.ceil(seconds) + 's';
    }
    function getActionCode(action) {
        return game.save.keybinds[action] || DEFAULT_KEYBINDS[action] || '';
    }
    const getActionAliases = (action) => {
       // костыль, переделать потом
       var a = [];
       if (action === 'move_up') a = ['ArrowUp'];
       if (action === 'move_down') a = ['ArrowDown'];
       if (action === 'move_left') a = ['ArrowLeft'];
       if (action === 'move_right') a = ['ArrowRight'];
       if (action === 'confirm_wave') a = ['Space'];
       return a;
    };
    function keyIs(code, action) {
        // хз почему но без двойной проверки иногда глючило у друга в firefox
        if (code === getActionCode(action)) return true;
        const aliases = getActionAliases(action);
        return aliases.includes(code);
    }
    const checkKey = (code, a) => keyIs(code, a);
    function kEq(code, a) {
        // максимально тупая версия, без алиасов
        return code == getActionCode(a);
    }
    function isActionPressed(action) {
        if (game.keysDown.has(getActionCode(action))) return true;
        const aliases = getActionAliases(action);
        for (let i = 0; i < aliases.length; i++) {
            if (game.keysDown.has(aliases[i])) return true;
        }
        return false;
    }
    function isFirePressed() {
        return game.mouse.down || game.keysDown.has('Space');
    }
    function getMovementDir() {
        let x = 0;
        let y = 0;
        if (isActionPressed('move_left')) x -= 1;
        if (isActionPressed('move_right')) x += 1;
        if (isActionPressed('move_up')) y -= 1;
        if (isActionPressed('move_down')) y += 1;
        const len = Math.hypot(x, y);
        if (len > 0) {
            x /= len;
            y /= len;
        }
        return { x: x, y: y, len: len };
    }
    function setArcadeButtonPressed(action, pressed) {
        ui.arcadeButtons.forEach((btn) => {
            if (btn.dataset.action === action) btn.classList.toggle('pressed', !!pressed);
        });
    }
    function updateArcadeDeck() {
        setArcadeButtonPressed('move_up', isActionPressed('move_up'));
        setArcadeButtonPressed('move_down', isActionPressed('move_down'));
        setArcadeButtonPressed('move_left', isActionPressed('move_left'));
        setArcadeButtonPressed('move_right', isActionPressed('move_right'));
        setArcadeButtonPressed('fire', isFirePressed());
        setArcadeButtonPressed('ability_dash', isActionPressed('ability_dash'));
        setArcadeButtonPressed('ability_shield', isActionPressed('ability_shield'));
        setArcadeButtonPressed('ability_emp', isActionPressed('ability_emp'));
        setArcadeButtonPressed('item_slot_1', isActionPressed('item_slot_1'));
        setArcadeButtonPressed('item_slot_2', isActionPressed('item_slot_2'));
        setArcadeButtonPressed('item_slot_3', isActionPressed('item_slot_3'));
        setArcadeButtonPressed('open_shop', isActionPressed('open_shop'));
        setArcadeButtonPressed('confirm_wave', isActionPressed('confirm_wave'));
    }
    function updateItemHUD() {
        const slotEls = [ui.itemSlot1, ui.itemSlot2, ui.itemSlot3];
        const cdEls = [ui.itemCd1, ui.itemCd2, ui.itemCd3];
        for (let i = 1; i <= 3; i++) {
            const sid = game.itemSlots[String(i)];
            const el = slotEls[i - 1];
            const cdEl = cdEls[i - 1];
            if (!el || !cdEl) continue;
            if (!sid || !ITEM_CATALOG[sid]) {
                el.classList.remove('ready');
                el.classList.add('cooldown');
                cdEl.textContent = 'Empty';
                continue;
            }
            const it = ITEM_CATALOG[sid];
            const state = game.itemState[sid] || { cd: 0, active: 0 };
            const txt = state.cd > 0 ? ('CD ' + formatCd(state.cd)) : 'Ready';
            cdEl.textContent = it.name + ' | ' + txt;
            if (state.cd > 0) {
                el.classList.remove('ready');
                el.classList.add('cooldown');
            } else {
                el.classList.remove('cooldown');
                el.classList.add('ready');
            }
        }
    }
    function updateHUD() {
        if (!game.player) return;
        ui.health.textContent = Math.max(0, Math.round(game.player.hp)) + ' / ' + Math.round(game.player.hpMax);
        ui.shield.textContent = Math.max(0, Math.round(game.player.shield));
        ui.resources.textContent = Math.floor(game.resources);
        ui.kills.textContent = Math.floor(game.kills);
        ui.stars.textContent = Math.floor(game.starsCollected);
        ui.waveNumber.textContent = String(game.enemyWave);
        ui.waveTimer.textContent = getWaveLeftCountSimple() + ' left';
        ui.scoreCurrent.textContent = Math.floor(game.score);
        if (ui.currentDifficulty) ui.currentDifficulty.textContent = game.difficultyPreset;
        ui.modifierName.textContent = game.activeWaveModifier ? WAVE_MODIFIERS[game.activeWaveModifier].name : 'None';
        ui.currentWeaponName.textContent = WEAPON_CATALOG[game.currentWeaponId] ? WEAPON_CATALOG[game.currentWeaponId].name : 'Unknown';
        ui.abilityDashCd.textContent = formatCd(game.abilityState.dash.cd);
        ui.abilityShieldCd.textContent = formatCd(game.abilityState.shield.cd);
        ui.abilityEmpCd.textContent = formatCd(game.abilityState.emp.cd);
        updateItemHUD();
    }
    function ensureAchievementState() {
        ACHIEVEMENTS.forEach((el) => {
            if (!game.save.achievements[el.id]) {
                game.save.achievements[el.id] = { unlocked: false, unlockedAt: '' };
            }
        });
    }
    function renderAchievements() {
        ensureAchievementState();
        ui.achievementList.innerHTML = ACHIEVEMENTS.map((el) => {
            const state = game.save.achievements[el.id];
            const cls = state && state.unlocked ? 'achievement-item unlocked' : 'achievement-item';
            const stamp = state && state.unlockedAt ? 'Unlocked: ' + new Date(state.unlockedAt).toLocaleString() : 'Locked';
            // а нужно ли это вообще?
            return '<div class="' + cls + '"><strong>' + el.name + '</strong><br/>' + el.desc + '<br/><span class="small-note">' + stamp + ' | Reward: ' + el.reward + ' MC</span></div>';
        }).join('');
    }
    function renderQuests() {
        if (!game.modeConfig.storyEnabled) {
            ui.questList.innerHTML = '<div class="small-note">Story quests are disabled in this mode.</div>';
            return;
        }
        ui.questList.innerHTML = game.quests.map((el) => {
            const cls = el.completed ? 'quest-item completed' : 'quest-item';
            return '<div class="' + cls + '">' + el.title + ' <div class="small-note">' + Math.min(el.current, el.target) + ' / ' + el.target + '</div></div>';
        }).join('');
    }
    function updateQuests() {
        if (!game.modeConfig.storyEnabled) return;
        let changed = false;
        game.quests.forEach((q) => {
            if (q.type === 'resources') q.current = Math.floor(game.totalRunStats.resources);
            if (q.type === 'kills') q.current = Math.floor(game.totalRunStats.kills);
            if (q.type === 'wave') q.current = Math.floor(game.enemyWave);
            if (q.type === 'boss_kills') q.current = Math.floor(game.totalRunStats.bossKills);
            if (!q.completed && q.current >= q.target) {
                q.completed = true;
                game.resources += 14;
                changed = true;
                showMessage('Quest complete: ' + q.title + ' (+14 resources)', '#7bff6a');
            }
        });
        if (changed) {
            renderQuests();
            saveProgress(game);
        }
        if (!game.winDialogShown && game.quests.every((q) => q.completed)) {
            game.winDialogShown = true;
            setTimeout(function () {
                if (game.state === 'playing') showDialog(DIALOGS.final_story);
            }, 400);
        }
    }
    function updateAchievements() {
        ensureAchievementState();
        let changed = false;
        ACHIEVEMENTS.forEach((a) => {
            const state = game.save.achievements[a.id];
            if (!state.unlocked && a.test(game)) {
                state.unlocked = true;
                state.unlockedAt = new Date().toISOString();
                game.save.metaCredits += a.reward;
                changed = true;
                showMessage('Achievement: ' + a.name + ' (+' + a.reward + ' MC)', '#7bff6a');
            }
        });
        if (changed) {
            applySaveToUI(game);
            renderAchievements();
            renderWeaponShop(game);
            renderItemShop();
            renderMetaShop(game);
            saveProgress(game);
        }
    }
    function applyChoiceEffect(effect) {
        if (!effect) return;
        if (effect.damageMult) game.choiceBuff.damageMult *= effect.damageMult;
        if (effect.speedMult) game.choiceBuff.speedMult *= effect.speedMult;
        if (effect.resourceMult) game.choiceBuff.resourceMult *= effect.resourceMult;
        if (effect.bonusShield) {
            game.choiceBuff.bonusShield += effect.bonusShield;
            game.player.shield = Math.min(game.player.shieldMax, game.player.shield + effect.bonusShield);
        }
    }
    function getCastProfile(charName) {
        return DIALOG_CAST[charName] || DIALOG_CAST.System;
    }
    function drawDialogPortrait(charName, mouthOpen, emotionId) {
        if (!dialogPortraitCtx || !ui.dialogPortrait) return;
        const profile = getCastProfile(charName);
        const w = ui.dialogPortrait.width;
        const h = ui.dialogPortrait.height;
        const scale = Math.max(0.24, w / 128);
        const p = (v) => v * scale;
        const cx = w / 2;
        const cy = h / 2;
        const talk = !!mouthOpen;
        const moodId = EMOTION_STATES[emotionId] ? emotionId : 'neutral';
        const mood = EMOTION_STATES[moodId] || EMOTION_STATES.neutral;
        dialogPortraitCtx.clearRect(0, 0, w, h);
        const bg = dialogPortraitCtx.createLinearGradient(0, 0, w, h);
        bg.addColorStop(0, profile.colorA);
        bg.addColorStop(1, profile.colorB);
        dialogPortraitCtx.fillStyle = bg;
        dialogPortraitCtx.fillRect(0, 0, w, h);
        const grain = Math.max(1, Math.round(p(2)));
        for (let i = 0; i < 20; i++) {
            const gx = (i * 17 + charName.length * 9) % w;
            const gy = (i * 13 + charName.length * 7) % h;
            dialogPortraitCtx.fillStyle = 'rgba(255,255,255,0.12)';
            dialogPortraitCtx.fillRect(gx, gy, grain, grain);
        }
        dialogPortraitCtx.lineWidth = Math.max(1, p(2));
        dialogPortraitCtx.strokeStyle = 'rgba(15,24,9,0.65)';
        if (profile.type === 'cat') {
            dialogPortraitCtx.fillStyle = '#dde2b8';
            dialogPortraitCtx.beginPath();
            dialogPortraitCtx.moveTo(cx - p(28), cy - p(18));
            dialogPortraitCtx.lineTo(cx - p(14), cy - p(36));
            dialogPortraitCtx.lineTo(cx - p(4), cy - p(14));
            dialogPortraitCtx.closePath();
            dialogPortraitCtx.fill();
            dialogPortraitCtx.beginPath();
            dialogPortraitCtx.moveTo(cx + p(28), cy - p(18));
            dialogPortraitCtx.lineTo(cx + p(14), cy - p(36));
            dialogPortraitCtx.lineTo(cx + p(4), cy - p(14));
            dialogPortraitCtx.closePath();
            dialogPortraitCtx.fill();
            dialogPortraitCtx.beginPath();
            dialogPortraitCtx.arc(cx, cy, p(30), 0, Math.PI * 2);
            dialogPortraitCtx.fill();
            dialogPortraitCtx.fillStyle = '#1a210f';
            dialogPortraitCtx.fillRect(cx - p(14), cy - p(7), p(7), p(7));
            dialogPortraitCtx.fillRect(cx + p(7), cy - p(7), p(7), p(7));
            if (talk) {
                dialogPortraitCtx.fillRect(cx - p(7), cy + p(9), p(14), p(7));
            } else {
                dialogPortraitCtx.fillRect(cx - p(11), cy + p(12), p(22), p(3));
            }
        } else if (profile.type === 'visor') {
            dialogPortraitCtx.fillStyle = '#d9e3a8';
            dialogPortraitCtx.fillRect(cx - p(34), cy - p(30), p(68), p(66));
            dialogPortraitCtx.strokeRect(cx - p(34), cy - p(30), p(68), p(66));
            dialogPortraitCtx.fillStyle = '#2f4520';
            dialogPortraitCtx.fillRect(cx - p(27), cy - p(14), p(54), p(16));
            dialogPortraitCtx.fillStyle = '#a4ba52';
            dialogPortraitCtx.fillRect(cx - p(24), cy - p(11), p(48), p(10));
            dialogPortraitCtx.fillStyle = '#253317';
            if (talk) dialogPortraitCtx.fillRect(cx - p(12), cy + p(14), p(24), p(7));
            else dialogPortraitCtx.fillRect(cx - p(15), cy + p(16), p(30), p(3));
        } else if (profile.type === 'ghost') {
            dialogPortraitCtx.fillStyle = '#d8e5b0';
            dialogPortraitCtx.beginPath();
            dialogPortraitCtx.arc(cx, cy - p(6), p(28), Math.PI, 0);
            dialogPortraitCtx.lineTo(cx + p(28), cy + p(23));
            dialogPortraitCtx.lineTo(cx + p(17), cy + p(16));
            dialogPortraitCtx.lineTo(cx + p(6), cy + p(24));
            dialogPortraitCtx.lineTo(cx - p(6), cy + p(16));
            dialogPortraitCtx.lineTo(cx - p(18), cy + p(24));
            dialogPortraitCtx.lineTo(cx - p(28), cy + p(14));
            dialogPortraitCtx.closePath();
            dialogPortraitCtx.fill();
            dialogPortraitCtx.fillStyle = '#1f2812';
            dialogPortraitCtx.fillRect(cx - p(12), cy - p(6), p(6), p(6));
            dialogPortraitCtx.fillRect(cx + p(6), cy - p(6), p(6), p(6));
            if (talk) dialogPortraitCtx.fillRect(cx - p(8), cy + p(10), p(16), p(6));
            else dialogPortraitCtx.fillRect(cx - p(10), cy + p(12), p(20), p(3));
        } else if (profile.type === 'toaster') {
            dialogPortraitCtx.fillStyle = '#cbd39b';
            dialogPortraitCtx.fillRect(cx - p(32), cy - p(24), p(64), p(56));
            dialogPortraitCtx.strokeRect(cx - p(32), cy - p(24), p(64), p(56));
            dialogPortraitCtx.fillStyle = '#2c381b';
            dialogPortraitCtx.fillRect(cx - p(18), cy - p(16), p(36), p(8));
            dialogPortraitCtx.fillStyle = '#5e6f33';
            dialogPortraitCtx.fillRect(cx + p(32), cy - p(4), p(8), p(18));
            dialogPortraitCtx.fillStyle = '#edf4c8';
            dialogPortraitCtx.fillRect(cx - p(14), cy - p(30), p(28), p(10));
            dialogPortraitCtx.fillStyle = '#2a3618';
            if (talk) dialogPortraitCtx.fillRect(cx - p(11), cy + p(12), p(22), p(6));
            else dialogPortraitCtx.fillRect(cx - p(14), cy + p(14), p(28), p(3));
        } else if (profile.type === 'orb') {
            dialogPortraitCtx.fillStyle = '#c8db87';
            dialogPortraitCtx.beginPath();
            dialogPortraitCtx.arc(cx, cy, p(26), 0, Math.PI * 2);
            dialogPortraitCtx.fill();
            dialogPortraitCtx.strokeStyle = '#9dbc3f';
            dialogPortraitCtx.beginPath();
            dialogPortraitCtx.arc(cx, cy, p(34), 0, Math.PI * 2);
            dialogPortraitCtx.stroke();
            dialogPortraitCtx.fillStyle = '#1b250f';
            if (talk) dialogPortraitCtx.fillRect(cx - p(6), cy + p(3), p(12), p(8));
            else dialogPortraitCtx.fillRect(cx - p(8), cy + p(6), p(16), p(3));
        } else {
            dialogPortraitCtx.fillStyle = '#dbe6b3';
            dialogPortraitCtx.beginPath();
            dialogPortraitCtx.arc(cx, cy - p(3), p(30), 0, Math.PI * 2);
            dialogPortraitCtx.fill();
            dialogPortraitCtx.fillStyle = '#1a250f';
            dialogPortraitCtx.fillRect(cx - p(10), cy - p(8), p(6), p(6));
            dialogPortraitCtx.fillRect(cx + p(4), cy - p(8), p(6), p(6));
            if (talk) dialogPortraitCtx.fillRect(cx - p(7), cy + p(10), p(14), p(6));
            else dialogPortraitCtx.fillRect(cx - p(10), cy + p(12), p(20), p(3));
        }
        const eyeShift = mood.eyeVariant === 'panic' ? -p(2) : (mood.eyeVariant === 'down' ? p(2) : 0);
        const eyeW = mood.eyeVariant === 'wide' ? p(8) : p(6);
        const eyeH = mood.eyeVariant === 'wide' ? p(6) : p(5);
        dialogPortraitCtx.fillStyle = '#1a220f';
        if (mood.eyeVariant === 'glitch') {
            dialogPortraitCtx.fillRect(cx - p(15), cy - p(9), p(6), p(4));
            dialogPortraitCtx.fillRect(cx + p(10), cy - p(5), p(7), p(4));
            dialogPortraitCtx.fillRect(cx - p(18), cy + p(2), p(3), p(2));
            dialogPortraitCtx.fillRect(cx + p(14), cy + p(1), p(3), p(2));
        } else if (mood.eyeVariant === 'uneven') {
            dialogPortraitCtx.fillRect(cx - p(14), cy - p(8), p(7), p(4));
            dialogPortraitCtx.fillRect(cx + p(8), cy - p(5), p(7), p(4));
        } else {
            dialogPortraitCtx.fillRect(cx - p(14), cy - p(8) + eyeShift, eyeW, eyeH);
            dialogPortraitCtx.fillRect(cx + p(8), cy - p(8) - eyeShift, eyeW, eyeH);
        }
        if (mood.browTilt !== 0) {
            const t = mood.browTilt;
            dialogPortraitCtx.fillRect(cx - p(16), cy - p(14) + t, p(9), p(2));
            dialogPortraitCtx.fillRect(cx + p(7), cy - p(14) - t, p(9), p(2));
        }
        if (!talk) {
            if (moodId === 'smug') {
                dialogPortraitCtx.fillRect(cx + p(2), cy + p(12), p(10), p(2));
            } else if (moodId === 'sad') {
                dialogPortraitCtx.fillRect(cx - p(8), cy + p(14), p(16), p(2));
                dialogPortraitCtx.fillRect(cx - p(10), cy + p(12), p(2), p(2));
                dialogPortraitCtx.fillRect(cx + p(8), cy + p(12), p(2), p(2));
            } else if (moodId === 'panic') {
                dialogPortraitCtx.fillRect(cx - p(5), cy + p(10), p(10), p(8));
            } else if (moodId === 'angry') {
                dialogPortraitCtx.fillRect(cx - p(10), cy + p(12), p(20), p(2));
            } else if (moodId === 'confused') {
                dialogPortraitCtx.fillRect(cx - p(2), cy + p(11), p(4), p(2));
            }
        }
        if (mood.tintMul > 0) {
            let tint = 'rgba(180,230,120,';
            if (moodId === 'panic') tint = 'rgba(255,150,120,';
            if (moodId === 'angry') tint = 'rgba(255,110,110,';
            if (moodId === 'sad') tint = 'rgba(155,188,15,';
            if (moodId === 'glitchy') tint = 'rgba(185,230,120,';
            dialogPortraitCtx.fillStyle = tint + (0.08 * mood.tintMul) + ')';
            dialogPortraitCtx.fillRect(0, 0, w, h);
        }
        dialogPortraitCtx.fillStyle = 'rgba(220,238,146,0.85)';
        dialogPortraitCtx.font = 'bold ' + Math.max(6, Math.round(p(11))) + 'px Lucida Console';
        dialogPortraitCtx.textAlign = 'right';
        dialogPortraitCtx.fillText(charName.slice(0, 14), w - Math.max(2, Math.round(p(6))), h - Math.max(2, Math.round(p(6))));
    }
    function setDialogSpeaker(charName, emotionId) {
        let speaker = 'System';
        if (charName !== undefined && charName !== null && String(charName).trim() !== '') {
            speaker = String(charName);
        }
        const moodId = EMOTION_STATES[emotionId] ? emotionId : 'neutral';
        const mood = EMOTION_STATES[moodId] || EMOTION_STATES.neutral;
        const rootCss = getComputedStyle(document.documentElement);
        const monoAccent = (rootCss.getPropertyValue('--accent') || '#9bbc0f').trim();
        const moodPalette = {
            neutral: '#c4d974', hype: '#e9f88b', panic: '#ffb089', angry: '#ff7f7f',
            smug: '#c3f0a0', sad: '#9fb95b', confused: '#d7d7a2', glitchy: '#b5e38a'
        };
        const moodColor = moodPalette[moodId] || monoAccent;
        ui.dialogName.textContent = speaker;
        if (ui.dialogMood) {
            ui.dialogMood.textContent = mood.label;
            ui.dialogMood.style.borderColor = moodColor;
            ui.dialogMood.style.color = moodColor;
        }
        if (ui.dialogAvatarTag) {
            ui.dialogAvatarTag.textContent = speaker;
        }
        if (ui.dialogAvatarTag) {
            ui.dialogAvatarTag.style.borderColor = monoAccent;
            ui.dialogAvatarTag.style.color = monoAccent;
        }
        if (ui.dialogName) {
            ui.dialogName.style.color = monoAccent;
        }
        if (ui.dialogTalkIcon) {
            ui.dialogTalkIcon.style.borderColor = monoAccent;
            ui.dialogTalkIcon.style.boxShadow = '0 0 8px rgba(155, 188, 15, 0.35)';
        }
        // хз почему, но если не обновлять портрет тут - иногда дергается
        drawDialogPortrait(speaker, false, moodId);
    }
    function animateDialogPortrait(nowMs) {
        if (!game.pauseReasons.dialog || ui.dialogBox.classList.contains('hidden')) return;
        let speaker = ui.dialogName && ui.dialogName.textContent ? ui.dialogName.textContent : 'System';
        let moodId = game.dialog.currentEmotion || 'neutral';
        const set = game.dialog.activeSet;
        if (set) {
            const idx = numOr(game.dialog.index, 0);
            const step = set[idx];
            if (step && step.char) speaker = String(step.char);
            if (step && step.emotion) moodId = String(step.emotion);
        }
        if (!EMOTION_STATES[moodId]) moodId = 'neutral';
        const mood = EMOTION_STATES[moodId] || EMOTION_STATES.neutral;
        const hasText = !!(ui.dialogText && String(ui.dialogText.textContent || '').trim());
        const rate = Math.max(40, numOr(mood.mouthRateMs, 110));
        const mouthOpen = hasText && (Math.floor(nowMs / rate) % 2 === 0);
        drawDialogPortrait(speaker, mouthOpen, moodId);
    }
    function showDialog(dialogSet) {
        if (!Array.isArray(dialogSet) || !dialogSet.length) return;
        game.dialog.activeSet = dialogSet;
        game.dialog.index = 0;
        game.dialog.choiceLocked = false;
        game.dialog.currentEmotion = 'neutral';
        game.pauseReasons.dialog = true;
        ui.dialogBox.classList.remove('hidden');
        renderDialogStep();
    }
    function renderDialogStep() {
        let step = null;
        let safe = 0;
        while (safe < 1000) {
            safe += 1;
            if (game.dialog.activeSet) {
                const maybeIndex = numOr(game.dialog.index, 0);
                step = game.dialog.activeSet[maybeIndex];
            } else {
                step = null;
            }
            if (!step || typeof step !== 'object') {
                hideDialog();
                return;
            }
            if (step.onceId && game.storyMilestonesSeen[step.onceId]) {
                game.dialog.index += 1;
                continue;
            }
            break;
        }
        if (!step || typeof step !== 'object') {
            hideDialog();
            return;
        }
        if (step.onceId) {
            game.storyMilestonesSeen[step.onceId] = true;
            if (step.onceId.indexOf('flavor_m') === 0) {
                const num = step.onceId.replace('flavor_m', '');
                game.storyMilestonesSeen['flavor_milestone_' + num] = true;
            }
        }
        const who = step.char ? String(step.char) : 'System';
        const moodId = step.emotion && EMOTION_STATES[step.emotion] ? String(step.emotion) : 'neutral';
        let txt = '';
        if (step.text === undefined || step.text === null) txt = '';
        else txt = String(step.text);
        game.dialog.currentEmotion = moodId;
        setDialogSpeaker(who, moodId);
        ui.dialogText.textContent = txt;
        // todo typewriter later maybe
        ui.dialogChoices.innerHTML = '';
        game.dialog.choiceLocked = false;
        const hasChoices = Array.isArray(step.choices) && step.choices.length > 0;
        if (hasChoices) {
            game.dialog.choiceLocked = true;
            for (let i = 0; i < step.choices.length; i++) {
                const choice = step.choices[i];
                const b = document.createElement('button');
                b.className = 'dialog-choice';
                b.textContent = choice && choice.label ? String(choice.label) : ('Choice ' + (i + 1));
                b.addEventListener('click', function () {
                    const fx = choice && choice.effect ? choice.effect : {};
                    applyChoiceEffect(fx);
                    game.dialog.choiceLocked = false;
                    nextDialog();
                });
                ui.dialogChoices.appendChild(b);
            }
        }
    }
    function nextDialog() {
        if (!game.dialog.activeSet) return;
        const step = game.dialog.activeSet[game.dialog.index];
        if (step && step.choices && game.dialog.choiceLocked) return;
        game.dialog.index += 1;
        if (game.dialog.index >= game.dialog.activeSet.length) {
            hideDialog();
            return;
        }
        renderDialogStep();
    }
    function hideDialog() {
        game.dialog.activeSet = null;
        game.dialog.index = 0;
        game.dialog.choiceLocked = false;
        game.dialog.currentEmotion = 'neutral';
        game.pauseReasons.dialog = false;
        ui.dialogBox.classList.add('hidden');
        if (ui.dialogTalkIcon) ui.dialogTalkIcon.style.boxShadow = 'none';
        if (ui.dialogMood) ui.dialogMood.textContent = 'Neutral';
    }
    function getWeaponBySlot(slot) {
        const key = String(slot);
        const id = game.weaponQuickSlots[key];
        if (id && WEAPON_CATALOG[id] && game.save.unlockedWeapons.includes(id)) return id;
        const def = DEFAULT_WEAPON_QUICK_SLOTS[key];
        if (def && WEAPON_CATALOG[def] && game.save.unlockedWeapons.includes(def)) return def;
        return 'starter_pistol';
    }
    function assignWeaponToQuickSlot(weaponId, slotIndex) {
        const key = String(slotIndex);
        if (!WEAPON_CATALOG[weaponId]) return false;
        if (!['1', '2', '3'].includes(key)) return false;
        if (!game.save.unlockedWeapons.includes(weaponId)) {
            showMessage('Weapon must be unlocked first.', '#ff477f');
            return false;
        }
        game.weaponQuickSlots[key] = weaponId;
        game.save.weaponQuickSlots = deepClone(game.weaponQuickSlots);
        if (String(game.currentWeaponId) === String(getWeaponBySlot(key)) || !WEAPON_CATALOG[game.currentWeaponId]) {
            game.currentWeaponId = weaponId;
        }
        saveProgress(game);
        showMessage('Quick slot ' + key + ' -> ' + WEAPON_CATALOG[weaponId].name, '#7bff6a');
        return true;
    }
    function equipWeapon(weaponId) {
        if (!WEAPON_CATALOG[weaponId]) return;
        if (!game.save.unlockedWeapons.includes(weaponId)) {
            showMessage('Weapon is locked. Buy it first.', '#ff477f');
            return;
        }
        game.currentWeaponId = weaponId;
        ui.currentWeaponName.textContent = WEAPON_CATALOG[weaponId].name;
        showMessage('Equipped: ' + WEAPON_CATALOG[weaponId].name, '#9bbc0f');
    }
    function tryEquipBySlot(slot) {
        const id = getWeaponBySlot(slot);
        if (id) equipWeapon(id);
    }
    function getRunUpgradeCost(upgradeId) {
        const cfg = RUN_UPGRADES[upgradeId];
        if (!cfg) return 9999;
        const level = game.runWeaponLevels[upgradeId] || 0;
        return Math.floor(cfg.base + level * cfg.step);
    }
    function buyRunUpgrade(upgradeId) {
        if (game.state !== 'playing' || !game.pauseReasons.wave) {
            showMessage('Run upgrades are available during wave pause.', '#ffb15a');
            return;
        }
        const cfg = RUN_UPGRADES[upgradeId];
        if (!cfg) return;
        const cost = getRunUpgradeCost(upgradeId);
        if (game.resources < cost) {
            showMessage('Not enough resources.', '#ff477f');
            return;
        }
        game.resources -= cost;
        game.runWeaponLevels[upgradeId] = (game.runWeaponLevels[upgradeId] || 0) + 1;
        if (upgradeId === 'health') {
            game.player.hpMax += 10;
            game.player.hp = Math.min(game.player.hpMax, game.player.hp + 10);
        }
        showMessage(cfg.name + ' upgraded', '#7bff6a');
        renderWeaponShop(game);
        updateHUD();
    }
    function unlockWeapon(weaponId) {
        const w = WEAPON_CATALOG[weaponId];
        if (!w) return;
        if (game.save.unlockedWeapons.includes(weaponId)) {
            equipWeapon(weaponId);
            return;
        }
        if (game.save.metaCredits < w.unlockCost) {
            showMessage('Not enough Meta Credits.', '#ff477f');
            return;
        }
        game.save.metaCredits -= w.unlockCost;
        game.save.unlockedWeapons.push(weaponId);
        applySaveToUI(game);
        renderWeaponShop(game);
        updateAchievements();
        saveProgress(game);
        showMessage(w.name + ' unlocked permanently', '#7bff6a');
    }
    function unlockAbility(abilityId) {
        const a = ABILITY_CATALOG[abilityId];
        if (!a) return;
        if (game.save.unlockedAbilities.includes(abilityId)) return;
        if (game.save.metaCredits < a.unlockCost) {
            showMessage('Not enough Meta Credits.', '#ff477f');
            return;
        }
        game.save.metaCredits -= a.unlockCost;
        game.save.unlockedAbilities.push(abilityId);
        applySaveToUI(game);
        renderMetaShop(game);
        updateAchievements();
        saveProgress(game);
        showMessage(a.name + ' unlocked permanently', '#7bff6a');
    }
    function unlockItem(itemId) {
        const item = ITEM_CATALOG[itemId];
        if (!item) return;
        if (game.save.unlockedItems.includes(itemId)) return;
        if (game.save.metaCredits < item.metaCost) {
            showMessage('Not enough Meta Credits.', '#ff477f');
            return;
        }
        game.save.metaCredits -= item.metaCost;
        game.save.unlockedItems.push(itemId);
        applySaveToUI(game);
        renderItemShop();
        renderMetaShop();
        saveProgress(game);
        showMessage(item.name + ' unlocked permanently', '#7bff6a');
    }
    function buyRunItem(itemId) {
        if (game.state !== 'playing' || !game.pauseReasons.wave) {
            showMessage('Run item purchase is only during wave pause.', '#ffb15a');
            return;
        }
        const item = ITEM_CATALOG[itemId];
        if (!item) return;
        if (!game.save.unlockedItems.includes(itemId)) {
            showMessage('Unlock this item in Meta first.', '#ff477f');
            return;
        }
        if (game.runItemsOwned.includes(itemId)) {
            showMessage('Already bought this run.', '#ffb15a');
            return;
        }
        if (game.resources < item.runCost) {
            showMessage('Not enough resources.', '#ff477f');
            return;
        }
        game.resources -= item.runCost;
        game.runItemsOwned.push(itemId);
        if (!game.itemState[itemId]) game.itemState[itemId] = { cd: 0, active: 0 };
        renderItemShop();
        updateHUD();
        showMessage(item.name + ' bought for this run', '#7bff6a');
    }
    function equipItemToSlot(itemId, slotIndex) {
        const item = ITEM_CATALOG[itemId];
        const key = String(slotIndex);
        if (!item || !['1', '2', '3'].includes(key)) return false;
        if (!game.runItemsOwned.includes(itemId)) {
            showMessage('Buy this item for the run first.', '#ff477f');
            return false;
        }
        game.itemSlots[key] = itemId;
        if (!game.itemState[itemId]) game.itemState[itemId] = { cd: 0, active: 0 };
        updateItemHUD();
        showMessage('Item slot ' + key + ' -> ' + item.name, '#9bbc0f');
        return true;
    }
    function closeAllShops() {
        ui.weaponShopPanel.classList.add('hidden');
        ui.itemShopPanel.classList.add('hidden');
        ui.metaShopPanel.classList.add('hidden');
    }
    function renderWeaponShop() {
        const weaponRows = Object.values(WEAPON_CATALOG).map((w) => {
            const unlocked = game.save.unlockedWeapons.includes(w.id);
            let actionHtml = '';
            const slotBits = ['1', '2', '3'].map((s) => {
                if (!unlocked) return '<button class="btn" disabled>S' + s + '</button>';
                const active = game.weaponQuickSlots[s] === w.id ? ' style="border-color:#7bff6a;"' : '';
                return '<button class="btn"' + active + ' data-assign-weapon-slot="' + w.id + '" data-slot="' + s + '">S' + s + '</button>';
            }).join('');
            if (unlocked) actionHtml = '<button class="btn" data-equip-weapon="' + w.id + '">Equip</button> ' + slotBits;
            else actionHtml = '<button class="btn accent" data-unlock-weapon="' + w.id + '">Buy ' + w.unlockCost + ' MC</button>';
            const stat = w.behavior ? ('<span class="small-note">' + w.behavior + '</span>') : '';
            return '<div class="shop-row"><span>' + w.name + ' ' + stat + '</span><span>' + actionHtml + '</span></div>';
        }).join('');
        const upgradeRows = Object.values(RUN_UPGRADES).map((u) => {
            const lvl = game.runWeaponLevels[u.id] || 0;
            const cost = getRunUpgradeCost(u.id);
            return '<div class="shop-row"><span>' + u.name + ' Lv.' + lvl + '</span><span><button class="btn" data-run-upgrade="' + u.id + '">Buy ' + cost + '</button></span></div>';
        }).join('');
        ui.weaponShopPanel.innerHTML = '' +
            '<h3 style="margin:0 0 8px;color:var(--accent);">Weapon Shop</h3>' +
            '<div class="shop-section"><div class="shop-title">Permanent Unlocks (Meta Credits)</div>' + weaponRows + '</div>' +
            '<div class="shop-section"><div class="shop-title">Run Upgrades (Resources)</div>' + upgradeRows + '</div>' +
            '<div class="shop-section"><div class="shop-title">Quick Slots</div><div class="small-note">S1: ' + (WEAPON_CATALOG[getWeaponBySlot(1)] ? WEAPON_CATALOG[getWeaponBySlot(1)].name : 'Empty') + ' | S2: ' + (WEAPON_CATALOG[getWeaponBySlot(2)] ? WEAPON_CATALOG[getWeaponBySlot(2)].name : 'Empty') + ' | S3: ' + (WEAPON_CATALOG[getWeaponBySlot(3)] ? WEAPON_CATALOG[getWeaponBySlot(3)].name : 'Empty') + '</div></div>' +
            '<div class="shop-row"><span>Resources</span><strong>' + Math.floor(game.resources) + '</strong></div>' +
            '<div class="shop-row"><span>Meta Credits</span><strong>' + Math.floor(game.save.metaCredits) + '</strong></div>' +
            '<button class="btn" data-close-shop="weapon">Close</button>';
    }
    function renderItemShop() {
        const permanentRows = Object.values(ITEM_CATALOG).map((item) => {
            const unlocked = game.save.unlockedItems.includes(item.id);
            const action = unlocked ? '<span class="small-note">Unlocked</span>' : '<button class="btn accent" data-unlock-item="' + item.id + '">Buy ' + item.metaCost + ' MC</button>';
            return '<div class="shop-row"><span>' + item.name + '</span><span>' + action + '</span></div>';
        }).join('');
        const runRows = Object.values(ITEM_CATALOG).filter((item) => game.save.unlockedItems.includes(item.id)).map((item) => {
            const bought = game.runItemsOwned.includes(item.id);
            if (!bought) {
                return '<div class="shop-row"><span>' + item.name + '</span><span><button class="btn" data-buy-run-item="' + item.id + '">Run Buy ' + item.runCost + ' R</button></span></div>';
            }
            const slotButtons = ['1', '2', '3'].map((s) => {
                const active = game.itemSlots[s] === item.id ? ' style="border-color:#7bff6a;"' : '';
                return '<button class="btn"' + active + ' data-equip-item-slot="' + item.id + '" data-item-slot="' + s + '">S' + s + '</button>';
            }).join('');
            return '<div class="shop-row"><span>' + item.name + ' <span class="small-note">cd ' + item.cooldown + 's</span></span><span>' + slotButtons + '</span></div>';
        }).join('');
        ui.itemShopPanel.innerHTML = '' +
            '<h3 style="margin:0 0 8px;color:var(--accent);">Item Shop</h3>' +
            '<div class="shop-section"><div class="shop-title">Permanent Item Unlocks (Meta Credits)</div>' + permanentRows + '</div>' +
            '<div class="shop-section"><div class="shop-title">Run Items (Resources)</div>' + (runRows || '<div class="small-note">Unlock an item in Meta first.</div>') + '</div>' +
            '<div class="shop-row"><span>Resources</span><strong>' + Math.floor(game.resources) + '</strong></div>' +
            '<div class="shop-row"><span>Meta Credits</span><strong>' + Math.floor(game.save.metaCredits) + '</strong></div>' +
            '<button class="btn" data-close-shop="item">Close</button>';
    }
    function renderMetaShop() {
        const abilityRows = Object.values(ABILITY_CATALOG).map((a) => {
            const unlocked = game.save.unlockedAbilities.includes(a.id);
            let actionHtml = unlocked ? '<span class="small-note">Unlocked</span>' : '<button class="btn accent" data-unlock-ability="' + a.id + '">Buy ' + a.unlockCost + ' MC</button>';
            return '<div class="shop-row"><span>' + a.name + '</span><span>' + actionHtml + '</span></div>';
        }).join('');
        ui.metaShopPanel.innerHTML = '' +
            '<h3 style="margin:0 0 8px;color:var(--accent);">Meta Shop</h3>' +
            '<div class="shop-section"><div class="shop-title">Permanent Ability Unlocks</div>' + abilityRows + '</div>' +
            '<div class="shop-section"><div class="shop-title">Progress</div>' +
            '<div class="shop-row"><span>Difficulty</span><span>' + ((DIFFICULTY_PRESETS[game.save.settings.difficultyPreset] || DIFFICULTY_PRESETS.medium).label) + '</span></div>' +
            '<div class="shop-row"><span>Items Unlocked</span><span>' + game.save.unlockedItems.length + ' / ' + Object.keys(ITEM_CATALOG).length + '</span></div>' +
            '<div class="shop-row"><span>Meta Credits</span><strong>' + Math.floor(game.save.metaCredits) + '</strong></div></div>' +
            '<button class="btn" data-close-shop="meta">Close</button>';
    }
    function showWeaponShop(show) {
        if (show && !game.pauseReasons.wave) {
            showMessage('Open shop during wave pause.', '#ffb15a');
            return;
        }
        if (show) {
            renderWeaponShop(game);
            if (game.pauseReasons.dialog) hideDialog();
            ui.wavePauseOverlay.classList.remove('hidden');
            closeAllShops();
        }
        ui.weaponShopPanel.classList.toggle('hidden', !show);
    }
    function showItemShop(show) {
        if (show && !game.pauseReasons.wave) {
            showMessage('Open shop during wave pause.', '#ffb15a');
            return;
        }
        if (show) {
            renderItemShop();
            if (game.pauseReasons.dialog) hideDialog();
            ui.wavePauseOverlay.classList.remove('hidden');
            closeAllShops();
        }
        ui.itemShopPanel.classList.toggle('hidden', !show);
    }
    function showMetaShop(show) {
        if (show && !game.pauseReasons.wave) {
            showMessage('Open shop during wave pause.', '#ffb15a');
            return;
        }
        if (show) {
            renderMetaShop(game);
            if (game.pauseReasons.dialog) hideDialog();
            ui.wavePauseOverlay.classList.remove('hidden');
            closeAllShops();
        }
        ui.metaShopPanel.classList.toggle('hidden', !show);
    }
    function startWavePause() {
        if (game.pauseReasons.wave || game.state !== 'playing') return;
        const leftForNow = getWaveLeftCountSimple();
        if (leftForNow > 0) return;
        // 3й раз чинил зависание тут
        game.pauseReasons.wave = true;
        game.pendingWave = game.enemyWave + 1;
        game.spawnTickets = [];
        clearBossFightState('wave_pause');
        ui.wavePauseText.textContent = 'Wave ' + game.enemyWave + ' complete. Enemies defeated: ' + game.waveKilled + '/' + game.waveSpawnTarget + '. Confirm Wave ' + game.pendingWave + ' when ready.';
        ui.wavePauseOverlay.classList.remove('hidden');
        ui.weaponShopPanel.classList.add('hidden');
        ui.itemShopPanel.classList.add('hidden');
        ui.metaShopPanel.classList.add('hidden');
        showMessage('Wave paused. Shop is available.', '#ffb15a');
        game.audio.setMusicState('menu');
        showDialog(makeNiceAbsurdWaveDialog(game.enemyWave));
        renderWeaponShop(game);
        renderItemShop(game);
        renderMetaShop(game);
        saveProgress(game);
    }
    function confirmNextWave() {
        const wavePauseOn = !!game.pauseReasons.wave;
        const canWork = game.state === 'playing';
        const wave_ok = wavePauseOn&&canWork;
        if (!wave_ok) return;
        console.log('go wave', game.enemyWave, game.pendingWave); // debug left here
        // tmp debug:
        // console.log('confirm wave', game.enemyWave, game.pendingWave);
        let _justForCheck = 0;
        _justForCheck = _justForCheck + 1;
        if (game.pauseReasons.dialog) {
            const dSet = game.dialog.activeSet;
            const dIdx = numOr(game.dialog.index, 0);
            const step = dSet ? dSet[dIdx] : null;
            const needPick = !!(step && step.choices && game.dialog.choiceLocked);
            if (needPick) {
                showMessage('Choose a dialog option first.', '#ffb15a');
                return
            }
            showMessage('Finish dialog first, then confirm wave.', '#ffb15a');
            return;
        }
        game.pauseReasons.wave = false;
        const maybePending = game.pendingWave;
        if (maybePending) game.enemyWave = maybePending;
        else game.enemyWave = game.enemyWave + 1;
        game.pendingWave = null;
        // game.enemyWave = 999;
        game.waveElapsed = 0;
        clearBossFightState('next_wave');
        setupWaveByNoobMath(game.enemyWave);
        if (game.player) {
            const heal = game.player.hpMax * 0.5 * numOr(game.difficulty.playerHeal, 1);
            game.player.hp = Math.min(game.player.hpMax, game.player.hp + heal);
        }
        ui.wavePauseOverlay.classList.add('hidden');
        ui.weaponShopPanel.classList.add('hidden');
        ui.itemShopPanel.classList.add('hidden');
        ui.metaShopPanel.classList.add('hidden');
        applyWaveModifier(game.enemyWave);
        const every = numOr(game.modeConfig.bossEvery, 3);
        if ((game.enemyWave % every) === 0) {
            spawnBossForWave(game.enemyWave);
        } else {
            game.audio.setMusicState('wave');
        }
        showMessage('Wave ' + game.enemyWave + ' started', '#9bbc0f');
        updateHUD();
        saveProgress(game);
    }
    function spawnResource(x, y, rewardValue) {
        const chunks = Math.max(1, Math.min(8, Math.round(rewardValue / 2)));
        let left = rewardValue;
        for (let i = 0; i < chunks; i++) {
            const value = i === chunks - 1 ? left : Math.max(1, Math.floor(rewardValue / chunks));
            left -= value;
            const angle = (Math.PI * 2 * i) / chunks + game.rand() * 0.5;
            const speed = 35 + game.rand() * 55;
            game.resourcesOnMap.push({
                x: x, y: y, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed, value: value, r: 6, life: 8
            });
        }
    }
    function spawnParticles(x, y, color, count) {
        for (let i = 0; i < count; i++) {
            const angle = game.rand() * Math.PI * 2;
            const speed = 35 + game.rand() * 130;
            game.particles.push({
                x: x, y: y, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed, life: 0.2 + game.rand() * 0.5, maxLife: 0.7, color: color
            });
        }
    }
    function spawnAmbientSmokeDot(x, y, kind) {
        const life = 0.8 + game.rand() * 1.7;
        game.smokeParticles.push({
            x: x,
            y: y,
            vx: (game.rand() - 0.5) * 24,
            vy: -(14 + game.rand() * 30),
            life: life,
            maxLife: life,
            s: 2 + Math.floor(game.rand() * 3),
            tone: Math.floor(game.rand() * 4),
            tw: game.rand() * 8,
            kind: kind || 'ambient'
        });
    }
    function damagePlayer(amount, bypassInvuln) {
        if (game.state !== 'playing' || !game.player) return;
        if (!bypassInvuln && game.player.invuln > 0) return;
        let dmg = amount * numOr(game.difficulty.enemyDamage, 1);
        if (game.abilityState.shield.active > 0) dmg *= 0.62;
        if (game.itemEffectsRuntime.aegis > 0) dmg *= 0.55;
        if (game.player.shield > 0) {
            const absorb = Math.min(game.player.shield, dmg);
            game.player.shield -= absorb;
            dmg -= absorb;
        }
        if (dmg > 0) game.player.hp -= dmg;
        if (!bypassInvuln) game.player.invuln = 0.34;
        if (game.player.hp <= 0) {
            game.player.hp = 0;
            updateHUD();
            endRun();
        }
    }
    function resolveEnemyIndex(enemy, hintedIndex) {
        if (!enemy) return -1;
        // костыль: иногда прилетал уже неактуальный индекс после сплайса
        if (Number.isInteger(hintedIndex) && hintedIndex >= 0 && hintedIndex < game.enemies.length) {
            if (game.enemies[hintedIndex] && game.enemies[hintedIndex].id === enemy.id) return hintedIndex;
        }
      var i = game.enemies.length - 1;
        for (; i >= 0; i--) {
            if (game.enemies[i] && game.enemies[i].id === enemy.id) return i;
        }
        return -1;
    }
    function handleEnemyDeath(enemy, index) {
        const idx = resolveEnemyIndex(enemy, index);
        if (idx < 0) return false;
        const live = game.enemies[idx];
        if (!live || live.deathHandled) return false;
        live.deathHandled = true;
        if (live.typeId === 'splitter' && !live.splitDone) {
            live.splitDone = true;
            for (let i = 0; i < 2; i++) {
                const angle = game.rand() * Math.PI * 2;
                game.enemies.push({
                    id: game.nextEntityId++, typeId: 'mini', x: live.x + Math.cos(angle) * 8, y: live.y + Math.sin(angle) * 8,
                    hp: ENEMY_TYPES.mini.hp, maxHp: ENEMY_TYPES.mini.hp, speed: ENEMY_TYPES.mini.speed + game.enemyWave * 0.6,
                    baseSpeed: ENEMY_TYPES.mini.speed + game.enemyWave * 0.6, baseContactDamage: ENEMY_TYPES.mini.contact,
                    size: ENEMY_TYPES.mini.size, reward: ENEMY_TYPES.mini.reward, contactDamage: ENEMY_TYPES.mini.contact,
                    color: ENEMY_TYPES.mini.color, elitePrefix: null, eliteData: null,
                    cooldown: 0, dashTimer: 0, telegraph: 0, stunned: 0, splitDone: true, touchCd: 0,
                    deathHandled: false, commandBuffTimer: 0, signatureCd: 0, signatureActive: 0, signatureState: null,
                    requisitionBonusMarks: 0
                });
            }
        }
        if (live.typeId === 'boss') {
            game.bossKills += 1;
            game.totalRunStats.bossKills += 1;
            clearBossFightState('boss_down');
            game.audio.setMusicState('wave');
        }
        game.kills += 1;
        game.waveKilled += 1;
        game.totalRunStats.kills += 1;
        game.score += (20 + game.enemyWave * 3) * numOr(game.difficulty.scoreGain, 1);
        const reward = Math.max(1, Math.floor(live.reward * game.waveEffects.resourceBonus * game.choiceBuff.resourceMult * numOr(game.difficulty.resourceGain, 1)));
        spawnResource(live.x, live.y, reward);
        spawnParticles(live.x, live.y, live.eliteData ? live.eliteData.tint : live.color, live.typeId === 'boss' ? 36 : 12);
        game.enemies.splice(idx, 1);
        game.audio.kill();
        return true;
    }
    function updateSpawnQueue(nowMs) {
        for (let i = game.spawnTickets.length - 1; i >= 0; i--) {
            const ticket = game.spawnTickets[i];
            if (ticket.spawnAt <= nowMs) {
                spawnEnemyFromSchedule(ticket);
                if (ticket.typeId === 'boss') game.audio.setMusicState('boss');
                game.spawnTickets.splice(i, 1);
            }
        }
    }
    function updatePlayer(dt) {
        if (!game.player) return;
        const dir = getMovementDir();
        let speed = game.player.baseSpeed * (1 + game.runWeaponLevels.speed * 0.08) * game.choiceBuff.speedMult;
        if (game.player.slowTimer > 0) speed *= game.player.slowMult;
        game.player.x += dir.x * speed * dt;
        game.player.y += dir.y * speed * dt;
        if (game.player.dashVelocityX || game.player.dashVelocityY) {
            game.player.x += game.player.dashVelocityX * dt;
            game.player.y += game.player.dashVelocityY * dt;
            game.player.dashVelocityX *= Math.pow(0.08, dt);
            game.player.dashVelocityY *= Math.pow(0.08, dt);
            if (Math.abs(game.player.dashVelocityX) < 2) game.player.dashVelocityX = 0;
            if (Math.abs(game.player.dashVelocityY) < 2) game.player.dashVelocityY = 0;
        }
        game.player.x = clamp(game.player.x, game.player.radius + 2, game.width - game.player.radius - 2);
        game.player.y = clamp(game.player.y, game.player.radius + 2, game.height - game.player.radius - 2);
        game.player.angle = Math.atan2(game.mouse.y - game.player.y, game.mouse.x - game.player.x);
        if (isFirePressed()) fireWeapon(game.currentWeaponId, game.player.x, game.player.y, game.player.angle);
        if (game.player.invuln > 0) game.player.invuln -= dt;
        if (game.player.burnTimer > 0) {
            game.player.burnTimer -= dt;
            damagePlayer(game.player.burnDps * dt, true);
        }
        if (game.player.slowTimer > 0) {
            game.player.slowTimer -= dt;
            if (game.player.slowTimer <= 0) game.player.slowMult = 1;
        }
        Object.keys(game.abilityState).forEach((k) => {
            const slot = game.abilityState[k];
            if (slot.cd > 0) slot.cd -= dt;
            if (slot.active > 0) slot.active -= dt;
        });
        if (game.abilityState.shield.active > 0) {
            game.player.shield = Math.min(game.player.shieldMax, game.player.shield + dt * 4.5);
        }
    }
    function updateBullets(dt) {
        for (let i = game.bullets.length - 1; i >= 0; i--) {
            const b = game.bullets[i];
            b.age = numOr(b.age, 0) + dt;
            if (b.behavior === 'returning' && !b.returning && b.age >= numOr(b.returnAfter, 0.45)) {
                b.returning = true;
            }
            if (b.returning) {
                const dxr = game.player.x - b.x;
                const dyr = game.player.y - b.y;
                const dr = Math.max(0.001, Math.hypot(dxr, dyr));
                const rs = numOr(b.returnSpeed, 380);
                b.vx = (dxr / dr) * rs;
                b.vy = (dyr / dr) * rs;
            }
            b.x += b.vx * dt;
            b.y += b.vy * dt;
            b.life -= dt;
            if (b.life <= 0 || b.x < -30 || b.y < -30 || b.x > game.width + 30 || b.y > game.height + 30) {
                game.bullets.splice(i, 1);
                continue;
            }
            let hit = false;
            for (let e = game.enemies.length - 1; e >= 0; e--) {
                const enemy = game.enemies[e];
                if (b.hitList && b.hitList[enemy.id]) continue;
                const dx = enemy.x - b.x;
                const dy = enemy.y - b.y;
                const dist = Math.hypot(dx, dy);
                if (dist < enemy.size + b.radius) {
                    let direct = b.directDamage > 0 ? b.directDamage : b.damage;
                    if (enemy.typeId === 'boss' && enemy.passiveResist) direct *= Math.max(0.2, 1 - enemy.passiveResist);
                    enemy.hp -= direct;
                    game.audio.hit();
                    spawnParticles(b.x, b.y, b.color, 3);
                    if (b.hitList) b.hitList[enemy.id] = true;
                    if (b.behavior === 'explosive') {
                        const er = Math.max(24, numOr(b.explosionRadius, 64));
                        const ed = numOr(b.explosionDamage, b.damage * 0.8);
                        damageEnemiesInRadius(b.x, b.y, er, ed, 0);
                        spawnParticles(b.x, b.y, '#e7f8bf', 24);
                        hit = true;
                    } else if (numOr(b.pierceLeft, 0) > 0) {
                        b.pierceLeft -= 1;
                        hit = false;
                    } else {
                        hit = true;
                    }
                    if (hit) break;
                }
            }
            if (hit) game.bullets.splice(i, 1);
        }
    }
    function updateEnemyProjectiles(dt) {
        const timeMul = game.itemEffectsRuntime.timePocket > 0 ? 0.75 : 1;
        for (let i = game.enemyProjectiles.length - 1; i >= 0; i--) {
            const p = game.enemyProjectiles[i];
            p.x += p.vx * dt * timeMul;
            p.y += p.vy * dt * timeMul;
            p.life -= dt;
            if (p.life <= 0 || p.x < -25 || p.y < -25 || p.x > game.width + 25 || p.y > game.height + 25) {
                game.enemyProjectiles.splice(i, 1);
                continue;
            }
            const dx = p.x - game.player.x;
            const dy = p.y - game.player.y;
            if (Math.hypot(dx, dy) < game.player.radius + p.r) {
                damagePlayer(p.damage);
                game.enemyProjectiles.splice(i, 1);
            }
        }
    }
    function updateBossBehavior(enemy, ux, uy, dist, dt) {
        const cfg = BOSS_TYPES[enemy.bossKind] || BOSS_TYPES.dispatch_overlord;
        const oldPhase = enemy.phase || 1;
        const newPhase = getBossPhaseByHp(enemy);
        if (newPhase > oldPhase) {
            enemy.phase = newPhase;
            enemy.bossSummonCd = 0.35;
            enemy.bossSkillCd = 0.65;
            enemy.cooldown = 0.2;
            showMessage(cfg.name + ' phase ' + newPhase + '!', '#ffb15a');
            spawnParticles(enemy.x, enemy.y, cfg.color || enemy.color, 18 + newPhase * 8);
        }
        const phase = enemy.phase || 1;
        const moveMul = phase === 1 ? 1 : phase === 2 ? 1.13 : 1.26;
        enemy.x += ux * enemy.speed * moveMul * dt;
        enemy.y += uy * enemy.speed * moveMul * dt;
        if (enemy.bossSummonCd > 0) enemy.bossSummonCd -= dt;
        if (enemy.bossSkillCd > 0) enemy.bossSkillCd -= dt;
        if (enemy.bossSummonCd <= 0) {
            if (enemy.bossKind === 'dispatch_overlord') {
                if (phase === 1) spawnBossMinions(enemy, 'tank', 1);
                else if (phase === 2) { spawnBossMinions(enemy, 'tank', 1); spawnBossMinions(enemy, 'charger', 1); }
                else { spawnBossMinions(enemy, 'charger', 2); spawnBossMinions(enemy, 'tank', 1); }
                enemy.bossSummonCd = phase === 3 ? 4.8 : phase === 2 ? 5.9 : 7.2;
            } else if (enemy.bossKind === 'brood_matriarch') {
                if (phase === 1) spawnBossMinions(enemy, 'splitter', 1);
                else if (phase === 2) { spawnBossMinions(enemy, 'splitter', 1); spawnBossMinions(enemy, 'mini', 2); }
                else { spawnBossMinions(enemy, 'splitter', 1); spawnBossMinions(enemy, 'mini', 3); }
                enemy.bossSummonCd = phase === 3 ? 4.6 : phase === 2 ? 5.8 : 6.9;
            } else {
                if (phase === 1) spawnBossMinions(enemy, 'sniper', 1);
                else if (phase === 2) { spawnBossMinions(enemy, 'sniper', 1); spawnBossMinions(enemy, 'grunt', 1); }
                else { spawnBossMinions(enemy, 'sniper', 2); spawnBossMinions(enemy, 'charger', 1); }
                enemy.bossSummonCd = phase === 3 ? 5.1 : phase === 2 ? 6.2 : 7.1;
            }
        }
        if (enemy.bossSkillCd <= 0) {
            if (enemy.bossKind === 'dispatch_overlord') {
                let allies = 0;
                for (let i = 0; i < game.enemies.length; i++) {
                    const ally = game.enemies[i];
                    if (ally.id === enemy.id || ally.typeId === 'boss') continue;
                    const ad = Math.hypot(ally.x - enemy.x, ally.y - enemy.y);
                    if (ad > 320) continue;
                    const pdx = game.player.x - ally.x;
                    const pdy = game.player.y - ally.y;
                    const pd = Math.max(0.001, Math.hypot(pdx, pdy));
                    ally.x += (pdx / pd) * (30 + phase * 12) * dt;
                    ally.y += (pdy / pd) * (30 + phase * 12) * dt;
                    if (phase >= 2 && (ally.typeId === 'grunt' || ally.typeId === 'charger' || ally.typeId === 'tank')) {
                        ally.hp = Math.min(ally.maxHp, ally.hp + dt * (phase === 3 ? 2.3 : 1.0));
                    }
                    allies += 1;
                }
                if (phase === 3 && allies > 0) enemy.hp = Math.min(enemy.maxHp, enemy.hp + allies * 0.16);
                enemy.bossSkillCd = phase === 3 ? 4.1 : 5.8;
            } else if (enemy.bossKind === 'brood_matriarch') {
                let minis = 0;
                let splitters = 0;
                for (let i = 0; i < game.enemies.length; i++) {
                    const ally = game.enemies[i];
                    if (ally.id === enemy.id || ally.typeId === 'boss') continue;
                    if (ally.typeId === 'mini') minis += 1;
                    if (ally.typeId === 'splitter') {
                        splitters += 1;
                        if (phase >= 2) ally.hp = Math.min(ally.maxHp, ally.hp + dt * (phase === 3 ? 3.0 : 1.2));
                    }
                }
                if (phase >= 2 && minis > 0) enemy.hp = Math.min(enemy.maxHp, enemy.hp + minis * 0.2 * phase);
                if (phase === 3 && splitters > 0 && game.rand() < 0.4) spawnBossMinions(enemy, 'mini', 1);
                enemy.bossSkillCd = phase === 3 ? 3.8 : 5.4;
            } else {
                const snipers = [];
                for (let i = 0; i < game.enemies.length; i++) {
                    const ally = game.enemies[i];
                    if (ally.id === enemy.id || ally.typeId === 'boss') continue;
                    if (ally.typeId === 'sniper') snipers.push(ally);
                }
                if (snipers.length > 0) {
                    const power = phase === 3 ? 1.34 : phase === 2 ? 1.14 : 1.0;
                    for (let i = 0; i < snipers.length && i < 6; i++) {
                        const s = snipers[i];
                        fireDirectedEnemyShot(s.x, s.y, game.player.x, game.player.y, (240 + game.enemyWave * 4.4) * power, 4, 7 + game.enemyWave * 0.7 * power, cfg.shotColor, 2.9);
                        s.cooldown = Math.max(s.cooldown || 0, 0.55);
                    }
                } else if (phase >= 2) {
                    spawnBossMinions(enemy, 'sniper', 1);
                }
                if (phase === 3) {
                    for (let i = 0; i < game.enemies.length; i++) {
                        const ally = game.enemies[i];
                        if (ally.id === enemy.id || ally.typeId === 'boss') continue;
                        if (ally.typeId !== 'grunt' && ally.typeId !== 'charger') continue;
                        const ad = Math.hypot(ally.x - enemy.x, ally.y - enemy.y);
                        if (ad > 290) continue;
                        const pdx = game.player.x - ally.x;
                        const pdy = game.player.y - ally.y;
                        const pd = Math.max(0.001, Math.hypot(pdx, pdy));
                        ally.x += (pdx / pd) * 42 * dt;
                        ally.y += (pdy / pd) * 42 * dt;
                    }
                }
                enemy.bossSkillCd = phase === 3 ? 3.4 : 5.0;
            }
        }
        if (enemy.cooldown <= 0) {
            if (enemy.bossKind === 'dispatch_overlord') {
                const volley = 6 + phase * 2 + Math.min(6, Math.floor(game.enemyWave / 3));
                const sp = 180 + game.enemyWave * 5;
                for (let s = 0; s < volley; s++) {
                    const ang = (Math.PI * 2 * s) / volley + game.rand() * 0.18;
                    game.enemyProjectiles.push({
                        x: enemy.x, y: enemy.y, vx: Math.cos(ang) * sp, vy: Math.sin(ang) * sp,
                        r: 5, damage: 7 + game.enemyWave * 1.15, color: cfg.shotColor, life: 3.3
                    });
                }
                enemy.cooldown = phase === 3 ? 0.96 : 1.3;
            } else if (enemy.bossKind === 'brood_matriarch') {
                const volley = 5 + phase;
                const sp = 165 + game.enemyWave * 4;
                for (let s = 0; s < volley; s++) {
                    const ang = (Math.PI * 2 * s) / volley + game.rand() * 0.26;
                    game.enemyProjectiles.push({
                        x: enemy.x, y: enemy.y, vx: Math.cos(ang) * sp, vy: Math.sin(ang) * sp,
                        r: 5, damage: 6 + game.enemyWave * 1.0, color: cfg.shotColor, life: 3.6
                    });
                }
                if (phase >= 3) {
                    const volley2 = 4 + Math.floor(game.enemyWave / 4);
                    const sp2 = 215 + game.enemyWave * 3.5;
                    for (let s = 0; s < volley2; s++) {
                        const ang2 = (Math.PI * 2 * s) / volley2 + game.rand() * 0.15;
                        game.enemyProjectiles.push({
                            x: enemy.x, y: enemy.y, vx: Math.cos(ang2) * sp2, vy: Math.sin(ang2) * sp2,
                            r: 4, damage: 5 + game.enemyWave * 0.8, color: '#ffd0e9', life: 2.7
                        });
                    }
                }
                enemy.cooldown = phase === 3 ? 0.92 : 1.2;
            } else {
                const burst = 3 + phase * 2;
                const base = Math.atan2(game.player.y - enemy.y, game.player.x - enemy.x);
                const sp = 230 + game.enemyWave * 5 + phase * 16;
                for (let b = 0; b < burst; b++) {
                    const off = (b - (burst - 1) / 2) * 0.1;
                    game.enemyProjectiles.push({
                        x: enemy.x, y: enemy.y, vx: Math.cos(base + off) * sp, vy: Math.sin(base + off) * sp,
                        r: 5, damage: 7 + game.enemyWave * 1.05, color: cfg.shotColor, life: 3.1
                    });
                }
                if (phase >= 2) {
                    const ring = 4 + phase;
                    const rsp = 185 + game.enemyWave * 4;
                    for (let s = 0; s < ring; s++) {
                        const ang = (Math.PI * 2 * s) / ring + game.rand() * 0.14;
                        game.enemyProjectiles.push({
                            x: enemy.x, y: enemy.y, vx: Math.cos(ang) * rsp, vy: Math.sin(ang) * rsp,
                            r: 4, damage: 5 + game.enemyWave * 0.8, color: '#b7cf66', life: 2.6
                        });
                    }
                }
                enemy.cooldown = phase === 3 ? 0.82 : 1.08;
            }
        }
    }
    function getSpectacleCount(baseCount) {
        return Math.max(1, Math.round(baseCount * numOr(BOSS_SPECTACLE_TUNING.vfxMul, 1)));
    }
    function setBossTraitStatus(text, color) {
        const t = text || 'No active signature';
        const c = color || '#c3d66f';
        game.bossFight.traitText = t;
        game.bossFight.traitColor = c;
        if (ui.bossTraitText) {
            ui.bossTraitText.textContent = t;
            ui.bossTraitText.style.color = c;
        }
    }
    function countEnemiesByType(typeId) {
        let n = 0;
        for (let i = 0; i < game.enemies.length; i++) if (game.enemies[i].typeId === typeId) n += 1;
        return n;
    }
    function removeEnemySilently(enemy) {
        const idx = resolveEnemyIndex(enemy, -1);
        if (idx < 0) return false;
        const e = game.enemies[idx];
        if (!e || e.typeId === 'boss') return false;
        e.deathHandled = true;
        spawnParticles(e.x, e.y, e.color || '#c3d66f', 6);
        game.enemies.splice(idx, 1);
        return true;
    }
    function consumeNearestMinis(boss, cap) {
        let consumed = 0;
        for (let step = 0; step < cap; step++) {
            let pick = null;
            let pickDist = Infinity;
            for (let i = 0; i < game.enemies.length; i++) {
                const e = game.enemies[i];
                if (!e || e.typeId !== 'mini') continue;
                const d = Math.hypot(e.x - boss.x, e.y - boss.y);
                if (d < pickDist && d <= 170) {
                    pick = e;
                    pickDist = d;
                }
            }
            if (!pick) break;
            if (removeEnemySilently(pick)) consumed += 1;
        }
        return consumed;
    }
    function fireEdgeCrossVolley(tx, ty, speed, damage, color, life) {
        fireDirectedEnemyShot(0, ty, tx, ty, speed, 4, damage, color, life);
        fireDirectedEnemyShot(game.width, ty, tx, ty, speed, 4, damage, color, life);
        fireDirectedEnemyShot(tx, 0, tx, ty, speed, 4, damage, color, life);
        fireDirectedEnemyShot(tx, game.height, tx, ty, speed, 4, damage, color, life);
    }
    function tickBossSignature(enemy, phase, dt, nowMs) {
        if (!enemy || enemy.typeId !== 'boss') return;
        // очень длинная функция, знаю, но пока не ломаем
        let tmp = 0;
        tmp += 1;
        if (enemy.signatureCd > 0) enemy.signatureCd -= dt;
        if (enemy.signatureActive > 0) enemy.signatureActive -= dt;
        const castBusy = game.bossFight.cast && game.bossFight.cast.bossId === enemy.id;
        if (enemy.signatureState && enemy.signatureState.id === 'dispatch_command_burst') {
            if (nowMs >= enemy.signatureState.activeUntil) {
                enemy.signatureState = null;
                setBossTraitStatus('No active signature', '#c3d66f');
            } else {
                setBossTraitStatus('Preparing Command Burst', '#d7c06d');
            }
        } else if (enemy.signatureState && enemy.signatureState.id === 'brood_frenzy') {
            const sig = BOSS_SIGNATURES.brood_frenzy;
            const st = enemy.signatureState;
            if (nowMs >= st.endAt) {
                enemy.signatureState = null;
                enemy.signatureActive = 0;
                setBossTraitStatus('No active signature', '#c3d66f');
            } else {
                const dx = game.player.x - enemy.x;
                const dy = game.player.y - enemy.y;
                const d = Math.max(0.001, Math.hypot(dx, dy));
                enemy.x += (dx / d) * enemy.speed * (numOr(sig.moveMul, 1.14) - 1) * dt;
                enemy.y += (dy / d) * enemy.speed * (numOr(sig.moveMul, 1.14) - 1) * dt;
                if (nowMs >= st.nextPulseAt) {
                    st.nextPulseAt = nowMs + numOr(sig.pulseEverySec, 1.2) * 1000;
                    const pr = numOr(sig.pulseRadius[phase], 90);
                    spawnBossTelegraph({
                        kind: 'circle',
                        x: enemy.x,
                        y: enemy.y,
                        r: pr,
                        warnUntil: nowMs + numOr(sig.pulseWarnMs, 700),
                        liveUntil: nowMs + numOr(sig.pulseWarnMs, 700) + numOr(sig.pulseLiveMs, 900),
                        damage: numOr(sig.pulseDamage[phase], 9),
                        color: '#f0bdd9'
                    });
                    const eaten = consumeNearestMinis(enemy, numOr(sig.consumeCap, 2));
                    if (eaten > 0) {
                        enemy.hp = Math.min(enemy.maxHp, enemy.hp + enemy.maxHp * numOr(sig.healMaxHpPct, 0.018) * eaten);
                        spawnParticles(enemy.x, enemy.y, '#ffd0e9', getSpectacleCount(10 + eaten * 4));
                    }
                }
                setBossTraitStatus('Brood Frenzy Active', '#ffb8d8');
            }
        } else if (enemy.signatureState && enemy.signatureState.id === 'relay_lock') {
            const sig = BOSS_SIGNATURES.relay_lock;
            const st = enemy.signatureState;
            const snipers = countEnemiesByType('sniper');
            if (snipers <= 0) {
                enemy.signatureState = null;
                enemy.signatureActive = 0;
                enemy.signatureCd = 1.2;
                setBossTraitStatus('No active signature', '#c3d66f');
                return;
            }
            if (nowMs >= st.resolveAt) {
                const speed = numOr(sig.projectileSpeed[phase], 260);
                const dmg = numOr(sig.projectileDamage[phase], 8) * numOr(BOSS_SPECTACLE_TUNING.telegraphDamageMul, 1);
                fireEdgeCrossVolley(st.lock.x, st.lock.y, speed, dmg, '#d5e68a', 3.1);
                fireEdgeCrossVolley(st.pred.x, st.pred.y, speed, dmg, '#b7cf66', 2.8);
                if (snipers >= numOr(sig.bonusSnipers, 3)) {
                    fireDirectedEnemyShot(0, 0, st.pred.x, st.pred.y, speed * 0.9, 4, dmg, '#8fb8da', 2.5);
                    fireDirectedEnemyShot(game.width, game.height, st.lock.x, st.lock.y, speed * 0.9, 4, dmg, '#8fb8da', 2.5);
                    const axis = game.rand() < 0.5 ? 'h' : 'v';
                    spawnBossTelegraph({
                        kind: 'lane',
                        axis: axis,
                        x: axis === 'v' ? st.lock.x : game.width * 0.5,
                        y: axis === 'h' ? st.lock.y : game.height * 0.5,
                        w: axis === 'v' ? 24 + phase * 4 : game.width,
                        h: axis === 'h' ? 24 + phase * 4 : game.height,
                        warnUntil: nowMs + 320,
                        liveUntil: nowMs + 1080,
                        tickMs: 220,
                        damage: phase === 1 ? 6 : phase === 2 ? 7.5 : 9,
                        color: '#8fae52'
                    });
                }
                game.audio.bossRelease();
                spawnParticles(enemy.x, enemy.y, '#a7c75f', getSpectacleCount(18));
                enemy.signatureState = null;
                enemy.signatureActive = 0;
                enemy.signatureCd = numOr(sig.cdByPhase[phase], 7.0);
                setBossTraitStatus('No active signature', '#c3d66f');
            } else {
                setBossTraitStatus('Relay Lock: Charging', '#a7c75f');
            }
        }
        if (castBusy) return;
        if (enemy.bossKind === 'dispatch_overlord' && !enemy.signatureState && enemy.signatureCd <= 0) {
            const sig = BOSS_SIGNATURES.dispatch_command_burst;
            const need = numOr(sig.needAllies[phase], 2);
            let tankNear = false;
            const buffTargets = [];
            for (let i = 0; i < game.enemies.length; i++) {
                const ally = game.enemies[i];
                if (!ally || ally.id === enemy.id || ally.typeId === 'boss') continue;
                if (ally.typeId !== 'grunt' && ally.typeId !== 'tank' && ally.typeId !== 'charger') continue;
                const d = Math.hypot(ally.x - enemy.x, ally.y - enemy.y);
                if (d > numOr(sig.allyRadius, 260)) continue;
                buffTargets.push(ally);
                if (ally.typeId === 'tank') tankNear = true;
            }
            if (buffTargets.length >= need) {
                enemy.signatureCd = numOr(sig.cdByPhase[phase], 9);
                enemy.signatureActive = 0.8;
                enemy.signatureState = { id: 'dispatch_command_burst', activeUntil: nowMs + numOr(sig.ringLiveMs, 800), preventUlt: true };
                setBossTraitStatus('Preparing Command Burst', '#d7c06d');
                spawnBossTelegraph({
                    kind: 'circle',
                    x: enemy.x,
                    y: enemy.y,
                    r: numOr(sig.allyRadius, 260),
                    warnUntil: nowMs + numOr(sig.ringWarnMs, 450),
                    liveUntil: nowMs + numOr(sig.ringLiveMs, 800),
                    damage: phase === 1 ? 7 : phase === 2 ? 8.5 : 10.2,
                    tickMs: 240,
                    color: '#d7c06d'
                });
                for (let i = 0; i < buffTargets.length; i++) {
                    buffTargets[i].commandBuffTimer = Math.max(buffTargets[i].commandBuffTimer || 0, numOr(sig.buffDuration, 2.4));
                }
                const shots = Math.floor(numOr(sig.shotCount[phase], 8));
                const sp = numOr(sig.shotSpeed[phase], 220);
                const dmg = numOr(sig.shotDamage[phase], 8) * numOr(BOSS_SPECTACLE_TUNING.telegraphDamageMul, 1);
                for (let s = 0; s < shots; s++) {
                    const ang = (Math.PI * 2 * s) / shots + game.rand() * 0.12;
                    game.enemyProjectiles.push({
                        x: enemy.x, y: enemy.y, vx: Math.cos(ang) * sp, vy: Math.sin(ang) * sp,
                        r: 4, damage: dmg, color: '#e4d495', life: 2.8
                    });
                }
                if (tankNear) enemy.requisitionBonusMarks = 2;
                spawnParticles(enemy.x, enemy.y, '#e4d495', getSpectacleCount(16));
            }
        } else if (enemy.bossKind === 'brood_matriarch' && !enemy.signatureState && enemy.signatureCd <= 0) {
            const sig = BOSS_SIGNATURES.brood_frenzy;
            const needMini = numOr(sig.triggerMini[phase], 7);
            const minis = countEnemiesByType('mini');
            if (minis >= needMini) {
                enemy.signatureCd = numOr(sig.cdByPhase[phase], 8.4);
                enemy.signatureActive = numOr(sig.durationSec, 4.0);
                enemy.signatureState = {
                    id: 'brood_frenzy',
                    endAt: nowMs + numOr(sig.durationSec, 4.0) * 1000,
                    nextPulseAt: nowMs + 260,
                    preventUlt: true
                };
                setBossTraitStatus('Brood Frenzy Active', '#ffb8d8');
                spawnParticles(enemy.x, enemy.y, '#f2b5d8', getSpectacleCount(22));
            }
        } else if (enemy.bossKind === 'signal_conductor' && !enemy.signatureState && enemy.signatureCd <= 0) {
            const sig = BOSS_SIGNATURES.relay_lock;
            const snipers = countEnemiesByType('sniper');
            if (snipers >= 1) {
                const dir = getMovementDir();
                const lock = { x: clamp(game.player.x, 20, game.width - 20), y: clamp(game.player.y, 20, game.height - 20) };
                const pred = {
                    x: clamp(game.player.x + dir.x * numOr(sig.predictDist, 130), 20, game.width - 20),
                    y: clamp(game.player.y + dir.y * numOr(sig.predictDist, 130), 20, game.height - 20)
                };
                enemy.signatureActive = numOr(sig.lockMs, 900) / 1000;
                enemy.signatureState = { id: 'relay_lock', lock: lock, pred: pred, resolveAt: nowMs + numOr(sig.lockMs, 900), preventUlt: true };
                setBossTraitStatus('Relay Lock: Charging', '#a7c75f');
                spawnBossTelegraph({ kind: 'circle', x: lock.x, y: lock.y, r: 24, warnUntil: nowMs + numOr(sig.lockMs, 900), liveUntil: nowMs + numOr(sig.lockMs, 900) + 360, damage: 0, color: '#a7c75f' });
                spawnBossTelegraph({ kind: 'circle', x: pred.x, y: pred.y, r: 24, warnUntil: nowMs + numOr(sig.lockMs, 900), liveUntil: nowMs + numOr(sig.lockMs, 900) + 360, damage: 0, color: '#8fae52' });
                game.audio.bossCharge();
            }
        }
    }
    function clearBossFightState(reason) {
        game.bossFight.activeBossId = null;
        game.bossFight.cast = null;
        game.bossFight.telegraphs = [];
        game.bossFight.hazards = [];
        game.bossFight.banner = { text: '', ttl: 0 };
        setBossTraitStatus('No active signature', '#c3d66f');
        if (ui.bossEncounterHud) ui.bossEncounterHud.style.display = 'none';
        if (ui.bossPhaseBanner) ui.bossPhaseBanner.style.display = 'none';
    }
    function showBossPhaseBanner(text, color) {
        if (!ui.bossPhaseBanner) return;
        ui.bossPhaseBanner.textContent = text;
        ui.bossPhaseBanner.style.borderColor = color || '#73872f';
        ui.bossPhaseBanner.style.display = 'block';
        game.bossFight.banner.text = text;
        game.bossFight.banner.ttl = 1.1;
    }
    function initBossRuntime(enemy, bossKind) {
        const cfg = BOSS_TYPES[bossKind] || BOSS_TYPES.dispatch_overlord;
        enemy.bossKind = cfg.id;
        enemy.phase = 1;
        enemy.bossUltCd = 2.2;
        enemy.bossPassiveTick = 0.15;
        enemy.phaseFlags = { 2: false, 3: false };
        enemy.lastUltId = null;
        enemy.bossCastSpeedMul = 1;
        enemy.passiveResist = 0;
        enemy.signatureCd = 1.8;
        enemy.signatureActive = 0;
        enemy.signatureState = null;
        enemy.requisitionBonusMarks = 0;
        enemy.contactDamage = numOr(enemy.baseContactDamage, enemy.contactDamage) * numOr(BOSS_SPECTACLE_TUNING.bossContactMul, 1);
        enemy.baseContactDamage = enemy.contactDamage;
        game.bossFight.activeBossId = enemy.id;
        if (ui.bossPhaseBadge) ui.bossPhaseBadge.textContent = 'Phase 1';
        setBossTraitStatus('No active signature', '#c3d66f');
        if (ui.bossEncounterHud) ui.bossEncounterHud.style.display = 'none';
    }
    function handleBossPhaseTransition(enemy, newPhase) {
        if (newPhase <= (enemy.phase || 1)) return;
        enemy.phase = newPhase;
        enemy.phaseFlags[newPhase] = true;
        enemy.bossSummonCd = 0.4;
        enemy.bossSkillCd = 0.5;
        enemy.bossUltCd = 0.35;
        enemy.cooldown = 0.2;
        const cfg = BOSS_TYPES[enemy.bossKind] || BOSS_TYPES.dispatch_overlord;
        const txt = cfg.name + ' phase ' + newPhase + '!';
        showMessage(txt, '#ffb15a');
        showBossPhaseBanner(txt.toUpperCase(), cfg.ring || '#73872f');
        spawnParticles(enemy.x, enemy.y, cfg.color || '#c3d66f', getSpectacleCount(22 + newPhase * 10));
        game.audio.phaseShift();
    }
    function tickBossPassive(enemy, phase, dt) {
        const cfg = BOSS_TYPES[enemy.bossKind] || BOSS_TYPES.dispatch_overlord;
        const passiveId = cfg.passiveId;
        enemy.passiveResist = 0;
        enemy.bossCastSpeedMul = 1;
        if (passiveId === 'command_grid') {
            let boosted = 0;
            for (let i = 0; i < game.enemies.length; i++) {
                const ally = game.enemies[i];
                if (ally.id === enemy.id || ally.typeId === 'boss') continue;
                const d = Math.hypot(ally.x - enemy.x, ally.y - enemy.y);
                if (d > 260) continue;
                if (ally.typeId !== 'grunt' && ally.typeId !== 'tank' && ally.typeId !== 'charger') continue;
                const spMul = phase === 1 ? 1.10 : phase === 2 ? 1.14 : 1.18;
                ally.speed = (ally.baseSpeed || ally.speed) * spMul;
                ally.contactDamage = (ally.baseContactDamage || ally.contactDamage) * (phase === 1 ? 1.08 : phase === 2 ? 1.12 : 1.16);
                boosted += 1;
            }
            if (phase >= 3 && boosted >= 5) {
                enemy.hp = Math.min(enemy.maxHp, enemy.hp + dt * 0.35 * boosted);
            }
        } else if (passiveId === 'hive_link') {
            let minis = 0;
            let splitters = 0;
            for (let i = 0; i < game.enemies.length; i++) {
                const ally = game.enemies[i];
                if (ally.id === enemy.id || ally.typeId === 'boss') continue;
                const d = Math.hypot(ally.x - enemy.x, ally.y - enemy.y);
                if (d > 240) continue;
                if (ally.typeId === 'mini') minis += 1;
                if (ally.typeId === 'splitter') splitters += 1;
            }
            enemy.passiveResist = Math.min(0.24, minis * 0.015);
            if (splitters > 0) enemy.hp = Math.min(enemy.maxHp, enemy.hp + splitters * 0.7 * dt);
        } else if (passiveId === 'relay_net') {
            let snipers = 0;
            for (let i = 0; i < game.enemies.length; i++) {
                const ally = game.enemies[i];
                if (ally.id === enemy.id || ally.typeId === 'boss') continue;
                if (ally.typeId === 'sniper') snipers += 1;
            }
            enemy.bossCastSpeedMul = 1 + Math.min(0.25, snipers * 0.05);
            if (snipers >= 3) enemy.hp = Math.min(enemy.maxHp, enemy.hp + 0.5 * dt);
        }
    }
    function spawnBossTelegraph(spec) {
        const now = performance.now();
        const obj = Object.assign({
            id: game.nextTicketId++,
            kind: 'circle',
            axis: 'h',
            x: 0, y: 0, r: 50, w: 80, h: 80,
            warnUntil: now + 900,
            liveUntil: now + 1800,
            damage: 9,
            slow: 0,
            tickMs: 220,
            nextTick: now + 900,
            color: '#c6de79',
            label: ''
        }, spec || {});
        obj.damage = numOr(obj.damage, 0) * numOr(BOSS_SPECTACLE_TUNING.telegraphDamageMul, 1);
        game.bossFight.telegraphs.push(obj);
        return obj;
    }
    function playerInsideTelegraph(tg) {
        if (!game.player) return false;
        if (tg.kind === 'lane') {
            if (tg.axis === 'h') return Math.abs(game.player.y - tg.y) <= Math.max(8, tg.h * 0.5);
            return Math.abs(game.player.x - tg.x) <= Math.max(8, tg.w * 0.5);
        }
        const dx = game.player.x - tg.x;
        const dy = game.player.y - tg.y;
        return Math.hypot(dx, dy) <= Math.max(8, tg.r);
    }
    function updateBossTelegraphs(nowMs, dt) {
        if (game.bossFight.banner.ttl > 0) {
            game.bossFight.banner.ttl -= dt;
            if (game.bossFight.banner.ttl <= 0 && ui.bossPhaseBanner) ui.bossPhaseBanner.style.display = 'none';
        }
        if (game.bossFight.cast && nowMs >= game.bossFight.cast.endAt) {
            resolveBossCast(game.bossFight.cast);
            game.bossFight.cast = null;
        }
        for (let i = game.bossFight.telegraphs.length - 1; i >= 0; i--) {
            const tg = game.bossFight.telegraphs[i];
            if (nowMs > tg.liveUntil) {
                game.bossFight.telegraphs.splice(i, 1);
                continue;
            }
            if (nowMs < tg.warnUntil) continue;
            if (nowMs >= tg.nextTick) {
                tg.nextTick = nowMs + tg.tickMs;
                if (playerInsideTelegraph(tg)) {
                    damagePlayer(tg.damage || 8);
                    if (tg.slow > 0) {
                        game.player.slowTimer = Math.max(game.player.slowTimer, 1.1);
                        game.player.slowMult = Math.min(game.player.slowMult, 1 - tg.slow);
                    }
                }
            }
        }
    }
    function drawBossTelegraphs() {
        const now = performance.now();
        for (let i = 0; i < game.bossFight.telegraphs.length; i++) {
            const tg = game.bossFight.telegraphs[i];
            const warning = now < tg.warnUntil;
            const lifeSpan = Math.max(1, tg.liveUntil - tg.warnUntil);
            const k = warning ? (1 - ((tg.warnUntil - now) / Math.max(1, tg.warnUntil - (tg.warnUntil - 800)))) : (1 - (tg.liveUntil - now) / lifeSpan);
            ctx.globalAlpha = warning ? (0.18 + 0.28 * Math.abs(Math.sin(now / 80))) : 0.22;
            ctx.fillStyle = warning ? '#7f943f' : (tg.color || '#b8d06a');
            ctx.strokeStyle = warning ? '#d8e6a8' : '#f2ffd1';
            ctx.lineWidth = 2;
            if (tg.kind === 'lane') {
                if (tg.axis === 'h') {
                    const h = Math.max(8, tg.h);
                    ctx.fillRect(0, Math.round(tg.y - h * 0.5), game.width, Math.round(h));
                } else {
                    const w = Math.max(8, tg.w);
                    ctx.fillRect(Math.round(tg.x - w * 0.5), 0, Math.round(w), game.height);
                }
            } else {
                ctx.beginPath();
                ctx.arc(tg.x, tg.y, Math.max(8, tg.r), 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = warning ? 0.7 : 0.5;
                ctx.stroke();
            }
            ctx.globalAlpha = 1;
        }
    }
    function drawBossEncounterHud(nowMs) {
        if (!ui.bossEncounterHud) return;
        const cast = game.bossFight.cast;
        const liveBoss = game.enemies.find((e) => e.typeId === 'boss' && e.id === game.bossFight.activeBossId);
        if (!liveBoss && !cast) {
            ui.bossEncounterHud.style.display = 'none';
            return;
        }
        // если не трогать каждый кадр, иногда оставался старый текст
        if (ui.bossTraitText) {
            ui.bossTraitText.textContent = game.bossFight.traitText || 'No active signature';
            ui.bossTraitText.style.color = game.bossFight.traitColor || '#c3d66f';
        }
        if (ui.bossPhaseBadge && liveBoss) ui.bossPhaseBadge.textContent = 'Phase ' + (liveBoss.phase || 1);
        if (cast) {
            const total = Math.max(1, cast.endAt - cast.startAt);
            const p = clamp((nowMs - cast.startAt) / total, 0, 1);
            ui.bossCastName.textContent = cast.label || 'Casting';
            ui.bossCastFill.style.width = Math.round(p * 100) + '%';
            ui.bossEncounterHud.style.display = 'block';
        } else if (liveBoss) {
            ui.bossCastName.textContent = (BOSS_TYPES[liveBoss.bossKind] ? BOSS_TYPES[liveBoss.bossKind].name : 'Boss') + ' pressure rising...';
            ui.bossCastFill.style.width = '0%';
            ui.bossEncounterHud.style.display = 'block';
        }
    }
    function startBossCast(enemy, abilityId, phase, nowMs) {
        const ability = BOSS_ABILITIES[abilityId];
        if (!ability) return false;
        const castMul = enemy.bossCastSpeedMul || 1;
        const windup = (ability.windupMs * numOr(BOSS_SPECTACLE_TUNING.windupMul, 1)) / castMul;
        const endAt = nowMs + windup;
        const cast = { bossId: enemy.id, bossKind: enemy.bossKind, abilityId: abilityId, phase: phase, startAt: nowMs, endAt: endAt, label: ability.name, targets: [] };
        game.bossFight.cast = cast;
        game.bossFight.activeBossId = enemy.id;
        game.audio.bossCharge();
        spawnParticles(enemy.x, enemy.y, (BOSS_TYPES[enemy.bossKind] && BOSS_TYPES[enemy.bossKind].color) || '#c3d66f', getSpectacleCount(12));
        ui.bossCastName.textContent = ability.name;
        ui.bossCastFill.style.width = '0%';
        ui.bossEncounterHud.style.display = 'block';
        if (abilityId === 'overtime_draft') {
            const lanes = phase === 1 ? 1 : phase === 2 ? 2 : 3;
            for (let i = 0; i < lanes; i++) {
                const axis = i % 2 === 0 ? 'h' : 'v';
                spawnBossTelegraph({
                    kind: 'lane',
                    axis: axis,
                    x: axis === 'v' ? (40 + game.rand() * (game.width - 80)) : game.width * 0.5,
                    y: axis === 'h' ? (40 + game.rand() * (game.height - 80)) : game.height * 0.5,
                    w: axis === 'v' ? 34 + phase * 5 : game.width,
                    h: axis === 'h' ? 34 + phase * 5 : game.height,
                    warnUntil: endAt,
                    liveUntil: endAt + ability.activeMs,
                    damage: phase === 1 ? 8 : phase === 2 ? 10 : 12,
                    tickMs: 250,
                    color: '#b7a451'
                });
            }
        } else if (abilityId === 'requisition_barrage') {
            const bonus = Math.max(0, Math.floor(numOr(enemy.requisitionBonusMarks, 0)));
            const marks = (phase === 1 ? 4 : phase === 2 ? 6 : 8) + bonus;
            enemy.requisitionBonusMarks = 0;
            for (let i = 0; i < marks; i++) {
                const tx = clamp(game.player.x + (game.rand() - 0.5) * 280, 30, game.width - 30);
                const ty = clamp(game.player.y + (game.rand() - 0.5) * 220, 30, game.height - 30);
                cast.targets.push({ x: tx, y: ty });
                spawnBossTelegraph({ kind: 'circle', x: tx, y: ty, r: 34 + phase * 4, warnUntil: endAt, liveUntil: endAt + 540, damage: phase === 1 ? 13 : phase === 2 ? 16 : 20, color: '#d7c06d' });
            }
        } else if (abilityId === 'egg_carousel') {
            const eggs = phase === 1 ? 5 : phase === 2 ? 7 : 9;
            for (let i = 0; i < eggs; i++) {
                const ang = (Math.PI * 2 * i) / eggs;
                const tx = clamp(enemy.x + Math.cos(ang) * (90 + game.rand() * 40), 28, game.width - 28);
                const ty = clamp(enemy.y + Math.sin(ang) * (90 + game.rand() * 40), 28, game.height - 28);
                cast.targets.push({ x: tx, y: ty });
                spawnBossTelegraph({ kind: 'circle', x: tx, y: ty, r: 20, warnUntil: endAt, liveUntil: endAt + 1200, damage: 7 + phase * 2, color: '#f0bdd9' });
            }
        } else if (abilityId === 'nest_pulse') {
            spawnBossTelegraph({ kind: 'circle', x: enemy.x, y: enemy.y, r: 88 + phase * 20, warnUntil: endAt, liveUntil: endAt + 420, damage: phase === 1 ? 10 : phase === 2 ? 12 : 14, slow: phase === 1 ? 0.2 : phase === 2 ? 0.25 : 0.3, color: '#ffb8d8' });
        } else if (abilityId === 'jammer_sweep') {
            const sweeps = phase === 1 ? 2 : phase === 2 ? 3 : 4;
            for (let i = 0; i < sweeps; i++) {
                const axis = i % 2 === 0 ? 'h' : 'v';
                spawnBossTelegraph({
                    kind: 'lane',
                    axis: axis,
                    x: axis === 'v' ? (60 + game.rand() * (game.width - 120)) : game.width * 0.5,
                    y: axis === 'h' ? (60 + game.rand() * (game.height - 120)) : game.height * 0.5,
                    w: axis === 'v' ? 30 + phase * 6 : game.width,
                    h: axis === 'h' ? 30 + phase * 6 : game.height,
                    warnUntil: endAt,
                    liveUntil: endAt + ability.activeMs,
                    damage: phase === 1 ? 7 : phase === 2 ? 9 : 11,
                    tickMs: 220,
                    color: '#8fae52'
                });
            }
        } else if (abilityId === 'crossfire_verdict') {
            const dir = getMovementDir();
            const t1 = { x: game.player.x, y: game.player.y };
            const t2 = { x: clamp(game.player.x + dir.x * 140, 30, game.width - 30), y: clamp(game.player.y + dir.y * 140, 30, game.height - 30) };
            cast.targets.push(t1, t2);
            spawnBossTelegraph({ kind: 'circle', x: t1.x, y: t1.y, r: 28, warnUntil: endAt, liveUntil: endAt + 460, damage: phase === 1 ? 9 : phase === 2 ? 11 : 13, color: '#a7c75f' });
            spawnBossTelegraph({ kind: 'circle', x: t2.x, y: t2.y, r: 28, warnUntil: endAt, liveUntil: endAt + 460, damage: phase === 1 ? 9 : phase === 2 ? 11 : 13, color: '#a7c75f' });
        }
        return true;
    }
    function resolveBossCast(castState) {
        const enemy = game.enemies.find((e) => e.id === castState.bossId && e.typeId === 'boss');
        if (!enemy) return;
        game.audio.bossRelease();
        const castColor = (BOSS_TYPES[enemy.bossKind] && BOSS_TYPES[enemy.bossKind].color) || '#c3d66f';
        spawnParticles(enemy.x, enemy.y, castColor, getSpectacleCount(12));
        const phase = castState.phase || enemy.phase || 1;
        if (castState.abilityId === 'requisition_barrage') {
            if (phase === 1) spawnBossMinions(enemy, 'tank', 1);
            else if (phase === 2) { spawnBossMinions(enemy, 'tank', 1); spawnBossMinions(enemy, 'charger', 1); }
            else { spawnBossMinions(enemy, 'tank', 1); spawnBossMinions(enemy, 'charger', 2); }
        } else if (castState.abilityId === 'egg_carousel') {
            const minis = phase === 1 ? 3 : phase === 2 ? 5 : 7;
            spawnBossMinions(enemy, 'mini', minis);
            if (phase >= 3) spawnBossMinions(enemy, 'splitter', 1);
        } else if (castState.abilityId === 'nest_pulse' && phase >= 3) {
            spawnBossTelegraph({ kind: 'circle', x: enemy.x, y: enemy.y, r: 140, warnUntil: performance.now() + 350, liveUntil: performance.now() + 780, damage: 11, slow: 0.22, color: '#ffb8d8' });
        } else if (castState.abilityId === 'crossfire_verdict') {
            const speed = phase === 1 ? 260 : phase === 2 ? 300 : 340;
            const dmg = (phase === 1 ? 9 : phase === 2 ? 11 : 13) * numOr(BOSS_SPECTACLE_TUNING.telegraphDamageMul, 1);
            for (let i = 0; i < castState.targets.length; i++) {
                const t = castState.targets[i];
                fireDirectedEnemyShot(0, t.y, t.x, t.y, speed, 4, dmg, '#d5e68a', 3.2);
                fireDirectedEnemyShot(game.width, t.y, t.x, t.y, speed, 4, dmg, '#d5e68a', 3.2);
                fireDirectedEnemyShot(t.x, 0, t.x, t.y, speed, 4, dmg, '#d5e68a', 3.2);
                fireDirectedEnemyShot(t.x, game.height, t.x, t.y, speed, 4, dmg, '#d5e68a', 3.2);
            }
            if (phase >= 3) {
                for (let i = 0; i < castState.targets.length; i++) {
                    const t2 = castState.targets[i];
                    fireDirectedEnemyShot(0, t2.y, t2.x, t2.y, speed * 0.92, 4, dmg, '#b7cf66', 2.7);
                    fireDirectedEnemyShot(game.width, t2.y, t2.x, t2.y, speed * 0.92, 4, dmg, '#b7cf66', 2.7);
                }
            }
        } else if (castState.abilityId === 'overtime_draft') {
            if (phase >= 2) spawnBossMinions(enemy, 'charger', 1);
        } else if (castState.abilityId === 'jammer_sweep') {
            for (let i = 0; i < game.enemies.length; i++) {
                const ally = game.enemies[i];
                if (ally.typeId === 'sniper') {
                    fireDirectedEnemyShot(ally.x, ally.y, game.player.x, game.player.y, 220 + phase * 24, 4, (7 + phase * 2) * numOr(BOSS_SPECTACLE_TUNING.telegraphDamageMul, 1), '#cde080', 2.6);
                }
            }
        }
        const cfg = BOSS_TYPES[enemy.bossKind] || BOSS_TYPES.dispatch_overlord;
        enemy.lastUltId = castState.abilityId;
        enemy.bossUltCd = numOr((cfg.baseUltCd && cfg.baseUltCd[phase]), 6.2) + game.rand() * 0.9;
    }
    function tryStartBossUltimate(enemy, phase, nowMs) {
        if (game.bossFight.cast && game.bossFight.cast.bossId === enemy.id) return;
        if (enemy.signatureState && enemy.signatureState.preventUlt) return;
        if (enemy.bossUltCd > 0) return;
        const cfg = BOSS_TYPES[enemy.bossKind] || BOSS_TYPES.dispatch_overlord;
        let list = (cfg.ultimates || []).slice();
        if (list.length > 1 && enemy.lastUltId) {
            const filtered = list.filter((id) => id !== enemy.lastUltId);
            if (filtered.length > 0) list = filtered;
        }
        if (list.length === 0) return;
        const next = pickRandom(game, list);
        startBossCast(enemy, next, phase, nowMs);
        enemy.bossUltCd = 2.4;
    }
    function updateBossBehavior2(enemy, ux, uy, dist, dt) {
        const oldPhase = enemy.phase || 1;
        updateBossBehavior(enemy, ux, uy, dist, dt);
        const phase = enemy.phase || getBossPhaseByHp(enemy);
        const now = performance.now();
        if (phase > oldPhase) handleBossPhaseTransition(enemy, phase);
        tickBossPassive(enemy, phase, dt);
        tickBossSignature(enemy, phase, dt, now);
        if (enemy.bossUltCd > 0) enemy.bossUltCd -= dt;
        tryStartBossUltimate(enemy, phase, now);
    }
    function updateEnemies(dt) {
        // NOTE: логика старая, но трогать опасно перед релизом
        const enemyDt = dt * (game.itemEffectsRuntime.timePocket > 0 ? 0.65 : 1);
        for (let i = game.enemies.length - 1; i >= 0; i--) {
            const enemy = game.enemies[i];
            if (enemy.baseSpeed) enemy.speed = enemy.baseSpeed;
            if (enemy.baseContactDamage) enemy.contactDamage = enemy.baseContactDamage;
            if ((enemy.commandBuffTimer || 0) > 0) {
                enemy.commandBuffTimer -= enemyDt;
                const sigSp = numOr(BOSS_SIGNATURES.dispatch_command_burst.speedMul, 1.16);
                enemy.speed *= sigSp;
                enemy.contactDamage *= 1.08;
            }
            if (enemy.hp <= 0) {
                handleEnemyDeath(enemy, i);
                continue;
            }
            if (enemy.touchCd > 0) enemy.touchCd -= dt;
            if (enemy.cooldown > 0) enemy.cooldown -= enemyDt;
            if (enemy.stunned > 0) {
                enemy.stunned -= enemyDt;
            } else {
                const dx = game.player.x - enemy.x;
                const dy = game.player.y - enemy.y;
                const dist = Math.max(0.0001, Math.hypot(dx, dy));
                const ux = dx / dist;
                const uy = dy / dist;
                // var testAggro = dist < 250; // maybe later
                if (enemy.typeId == 'grunt' || enemy.typeId === 'tank' || enemy.typeId === 'splitter' || enemy.typeId == 'mini') {
                    enemy.x += ux * enemy.speed * enemyDt;
                    enemy.y += uy * enemy.speed * enemyDt;
                } else if (enemy.typeId === 'charger') {
                    if (enemy.telegraph > 0) {
                        enemy.telegraph -= enemyDt;
                        if (enemy.telegraph <= 0) {
                            enemy.dashTimer = 0.35;
                            enemy.dashVx = ux * enemy.speed * 5.8;
                            enemy.dashVy = uy * enemy.speed * 5.8;
                        }
                    } else if (enemy.dashTimer > 0) {
                        enemy.dashTimer -= enemyDt;
                        enemy.x += enemy.dashVx * enemyDt;
                        enemy.y += enemy.dashVy * enemyDt;
                    } else {
                        enemy.x += ux * enemy.speed * 0.7 * enemyDt;
                        enemy.y += uy * enemy.speed * 0.7 * enemyDt;
                        if (enemy.cooldown <= 0) {
                            enemy.cooldown = 2.8;
                            enemy.telegraph = 0.45;
                        }
                    }
                } else if (enemy.typeId == 'sniper') {
                    if (dist < 170) {
                        enemy.x -= ux * enemy.speed * enemyDt;
                        enemy.y -= uy * enemy.speed * enemyDt;
                    } else if (dist > 260) {
                        enemy.x += ux * enemy.speed * enemyDt;
                        enemy.y += uy * enemy.speed * enemyDt;
                    }
                    if (enemy.cooldown <= 0 && dist < 390) {
                        enemy.cooldown = 1.9;
                        const speed = 250 + game.enemyWave * 4.5;
                        game.enemyProjectiles.push({
                            x: enemy.x, y: enemy.y, vx: ux * speed, vy: uy * speed,
                            r: 4, damage: 8 + game.enemyWave * 0.8, color: '#aef7a8', life: 2.8
                        });
                    }
                } else if (enemy.typeId == 'boss') {
                    updateBossBehavior2(enemy, ux, uy, dist, enemyDt);
                }
            }
            const cdx = enemy.x - game.player.x;
            const cdy = enemy.y - game.player.y;
            const touchDist = enemy.size + game.player.radius;
            if (Math.hypot(cdx, cdy) < touchDist && (enemy.touchCd || 0) <= 0) {
                enemy.touchCd = 0.45;
                damagePlayer(enemy.contactDamage);
                if (enemy.eliteData && enemy.eliteData.onContact) enemy.eliteData.onContact(game, enemy);
            }
            if (enemy.x < -130) enemy.x = -130;
            if (enemy.y < -130) enemy.y = -130;
            if (enemy.x > game.width + 130) enemy.x = game.width + 130;
            if (enemy.y > game.height + 130) enemy.y = game.height + 130;
        }
    }
    function updateResources(dt) {
        for (let i = game.resourcesOnMap.length - 1; i >= 0; i--) {
            var res = game.resourcesOnMap[i];
            const dx = game.player.x - res.x;
            const dy = game.player.y - res.y;
            const dist = Math.hypot(dx, dy);
            const magnetOn = game.itemEffectsRuntime.magnet > 0;
            const pullRadius = magnetOn ? 320 : 120;
            if (dist < pullRadius) {
                const pull = 250 / Math.max(25, dist);
                res.vx += (dx / Math.max(dist, 0.0001)) * pull * dt;
                res.vy += (dy / Math.max(dist, 0.0001)) * pull * dt;
            }
            res.x += res.vx * dt;
            res.y += res.vy * dt;
            res.vx *= Math.pow(0.12, dt);
            res.vy *= Math.pow(0.12, dt);
            res.life -= dt;
            if (dist < game.player.radius + res.r + 2) {
                const gain = magnetOn ? Math.max(1, Math.round(res.value * 1.25)) : res.value;
                game.resources += gain;
                game.starsCollected += 1;
                game.totalRunStats.resources += gain;
                game.score += gain * 2;
                game.resourcesOnMap.splice(i, 1);
                continue;
            }
            if (res.life <= 0) game.resourcesOnMap.splice(i, 1);
        }
    }
    function updateParticles(dt) {
        for (let i = game.particles.length - 1; i >= 0; i--) {
            const p = game.particles[i];
            p.x += p.vx * dt;
            p.y += p.vy * dt;
            p.life -= dt;
            if (p.life <= 0) {
                game.particles.splice(i, 1);
                continue;
            }
            p.vx *= Math.pow(0.02, dt);
            p.vy *= Math.pow(0.02, dt);
        }
    }
    function updateSmoke(dt) {
        const want = game.state === 'playing' ? 150 : 95;
        let baseRate = game.state === 'playing' ? 34 : 18;
        game.smokeTick = numOr(game.smokeTick, 0) + dt * baseRate;
        while (game.smokeTick >= 1 && game.smokeParticles.length < want) {
            game.smokeTick -= 1;
            const sx = game.rand() * game.width;
            const sy = game.height + game.rand() * 18;
            spawnAmbientSmokeDot(sx, sy, 'ambient');
        }
        if (game.player && game.state === 'playing' && game.smokeParticles.length < want + 90) {
            const smokeBurst = game.mouse.down ? 3 : 1;
            for (let i = 0; i < smokeBurst; i++) {
                if (game.rand() < 0.72) {
                    const ex = game.player.x - Math.cos(game.player.angle) * (game.player.radius + 9) + (game.rand() - 0.5) * 8;
                    const ey = game.player.y - Math.sin(game.player.angle) * (game.player.radius + 9) + (game.rand() - 0.5) * 8;
                    spawnAmbientSmokeDot(ex, ey, 'engine');
                }
            }
        }
        for (let i = game.smokeParticles.length - 1; i >= 0; i--) {
            const p = game.smokeParticles[i];
            p.tw += dt * 5.5;
            p.x += p.vx * dt + Math.sin(p.tw) * 6 * dt;
            p.y += p.vy * dt;
            p.life -= dt;
            p.vx *= Math.pow(0.35, dt);
            p.vy -= 5 * dt;
            if (p.life <= 0 || p.x < -30 || p.x > game.width + 30 || p.y < -40 || p.y > game.height + 40) {
                game.smokeParticles.splice(i, 1);
            }
        }
    }
    function updateWaveFlow(dt, nowMs) {
        // 3й раз переписываю эту функцию, не трогай если "просто работает"
        updateSpawnQueue(nowMs);
        game.waveElapsed = numOr(game.waveElapsed, 0) + numOr(dt, 0);
        let baseRate = 0.65 + numOr(game.enemyWave, 1) * 0.17;
        baseRate = baseRate * numOr(game.difficulty.spawnRate, 1);
        if (String(game.mode) == 'bossrush') {
            baseRate = baseRate * 0.82;
        } else {
            baseRate = baseRate * 1;
        }
       // old formula maybe:
       // baseRate = baseRate + game.enemyWave*0.01;
        const stillNeedSpawn = numOr(game.waveSpawned, 0) < numOr(game.waveSpawnTarget, 0);
        if (stillNeedSpawn) {
            const spawnRate = numOr(game.waveEffects.spawnRate, 1);
            game.spawnAccumulator = numOr(game.spawnAccumulator, 0) + numOr(dt, 0) * baseRate * spawnRate;
        }
        let guard = 999;
        while (game.spawnAccumulator >= 1 && numOr(game.waveSpawned, 0) < numOr(game.waveSpawnTarget, 0)) {
            queueRandomEnemySpawn();
            game.waveSpawned = numOr(game.waveSpawned, 0) + 1;
            game.spawnAccumulator = numOr(game.spawnAccumulator, 0) - 1;
            guard -= 1;
            if (guard <= 0) break;
        }
        const allQueued = numOr(game.waveSpawned, 0) >= numOr(game.waveSpawnTarget, 0);
        const noPending = (game.spawnTickets.length === 0);
        const noLiveEnemies = (game.enemies.length === 0);
        const mayPause = allQueued && noPending && noLiveEnemies;
        // console.log('wave check', allQueued, noPending, noLiveEnemies);
        if (mayPause) {
            startWavePause();
        }
    }
    function doStuff(dt, nowMs) {
        // оказывается без этого крашится на firefox
        updateWaveFlow(dt, nowMs);
    }
    function drawBackground(dt) {
        // тут можно было красивее, но и так ок
        ctx.fillStyle = '#0a0f06';
        ctx.fillRect(0, 0, game.width, game.height);
        for (let i = 0; i < game.starsBg.length; i++) {
            const s = game.starsBg[i];
            s.y += s.v * dt;
            if (s.y > game.height + 3) {
                s.y = -2;
                s.x = game.rand() * game.width;
            }
            ctx.fillStyle = 'rgba(170,198,95,0.42)';
            ctx.fillRect(Math.round(s.x), Math.round(s.y), Math.max(1, Math.round(s.s)), Math.max(1, Math.round(s.s)));
        }
        const shift = Math.floor(performance.now() / 120) % 6;
        ctx.fillStyle = 'rgba(186, 210, 102, 0.12)';
        for (let y = shift; y < game.height; y += 6) {
            const xOff = ((y / 6) | 0) % 2 === 0 ? 0 : 3;
            for (let x = xOff; x < game.width; x += 6) {
                ctx.fillRect(x, y, 1, 1);
            }
        }
        var grad = ctx.createLinearGradient(0, 0, 0, game.height);
        grad.addColorStop(0, 'rgba(11,16,7,0)');
        grad.addColorStop(1, 'rgba(0,0,0,0.45)');
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, game.width, game.height);
    }
    const SPR_RESOURCE = [
        '..2..',
        '.232.',
        '23432',
        '.232.',
        '..2..'
    ];
    const SPR_PROJECTILE = [
        '.2.',
        '242',
        '.2.'
    ];
    const SPR_PLAYER_RIGHT = [
        '....111....',
        '...12221...',
        '..1233321..',
        '.123444321.',
        '12341488221',
        '.123444321.',
        '..1233321..',
        '...12221...',
        '....111....'
    ];
    const SPR_PLAYER_UP = [
        '....1....',
        '...121...',
        '..12321..',
        '.1234321.',
        '.1234321.',
        '121488321',
        '123444321',
        '.1234321.',
        '..12321..',
        '...121...',
        '....1....'
    ];
    const SPR_PLAYER_DOWN = [
        '....1....',
        '...121...',
        '..12321..',
        '.1234321.',
        '123444321',
        '121488321',
        '123444321',
        '.1234321.',
        '..12321..',
        '...121...',
        '....1....'
    ];
    const SPR_ENEMIES = {
        grunt: [
            '..1111..',
            '.122221.',
            '12333321',
            '12148821',
            '12344321',
            '12333321',
            '.122221.',
            '..1111..'
        ],
        tank: [
            '...11111...',
            '..1222221..',
            '.123333321.',
            '12344444421',
            '12314884421',
            '12344444421',
            '.123333321.',
            '..1222221..',
            '...11111...'
        ],
        charger: [
            '....1....',
            '...121...',
            '..12321..',
            '.1234321.',
            '121488321',
            '.1234321.',
            '..12321..',
            '...121...',
            '....1....'
        ],
        sniper: [
            '...111...',
            '..12221..',
            '.1233321.',
            '123434321',
            '121488321',
            '123434321',
            '.1233321.',
            '..12221..',
            '...111...'
        ],
        splitter: [
            '..111.111..',
            '.122212221.',
            '12333333321',
            '12314884321',
            '.123333321.',
            '..1222221..',
            '...11111...'
        ],
        mini: [
            '.111.',
            '12321',
            '14881',
            '12321',
            '.111.'
        ],
        boss: [
            '.....11111.....',
            '....1222221....',
            '...123333321...',
            '..12344444321..',
            '.1234444444321.',
            '123444444444321',
            '123441488444321',
            '123444444444321',
            '.1234444444321.',
            '..12344444321..',
            '...123333321...',
            '....1222221....',
            '.....11111.....'
        ]
    };
    function mirrorPatternRows(rows) {
        const out = [];
        for (let i = 0; i < rows.length; i++) out.push(rows[i].split('').reverse().join(''));
        return out;
    }
    const SPR_PLAYER_LEFT = mirrorPatternRows(SPR_PLAYER_RIGHT);
    function facing4(angle) {
        const twoPi = Math.PI * 2;
        const a = (angle % twoPi + twoPi) % twoPi;
        if (a >= Math.PI * 0.25 && a < Math.PI * 0.75) return 'down';
        if (a >= Math.PI * 0.75 && a < Math.PI * 1.25) return 'left';
        if (a >= Math.PI * 1.25 && a < Math.PI * 1.75) return 'up';
        return 'right';
    }
    function drawPatternCentered(pattern, cx, cy, pixelSize, palette, alpha) {
        if (!pattern || !pattern.length) return;
        const h = pattern.length;
        const w = pattern[0].length;
        const sx = Math.round(cx - (w * pixelSize) / 2);
        const sy = Math.round(cy - (h * pixelSize) / 2);
        const oldAlpha = ctx.globalAlpha;
        if (alpha !== undefined) ctx.globalAlpha = alpha;
        for (let y = 0; y < h; y++) {
            const row = pattern[y];
            for (let x = 0; x < row.length; x++) {
                const c = row.charAt(x);
                if (c === '.' || c === '0') continue;
                ctx.fillStyle = palette[c] || palette.default || '#73872f';
                ctx.fillRect(sx + x * pixelSize, sy + y * pixelSize, pixelSize, pixelSize);
            }
        }
        ctx.globalAlpha = oldAlpha;
    }
    function drawPixelRing(cx, cy, radius, color, pixelSize, step) {
        ctx.fillStyle = color;
        const s = pixelSize || 2;
        const d = step || 0.25;
        for (let a = 0; a < Math.PI * 2; a += d) {
            const x = Math.round(cx + Math.cos(a) * radius);
            const y = Math.round(cy + Math.sin(a) * radius);
            ctx.fillRect(x - Math.floor(s / 2), y - Math.floor(s / 2), s, s);
        }
    }
    function getEnemyPalette(enemy) {
        const elite = !!enemy.eliteData;
        let c2 = '#4f6129';
        let c3 = '#8da54b';
        let c4 = '#c3d66f';
        if (enemy.typeId === 'tank') {
            c2 = '#3f4f23';
            c3 = '#7b9441';
            c4 = '#b4cb63';
        } else if (enemy.typeId === 'charger') {
            c2 = '#5a6d31';
            c3 = '#97b24f';
            c4 = '#d0e07b';
        } else if (enemy.typeId === 'sniper') {
            c2 = '#445628';
            c3 = '#7f9a43';
            c4 = '#b7cf66';
        } else if (enemy.typeId === 'boss') {
            if (enemy.bossKind === 'brood_matriarch') {
                c2 = '#6e3d53';
                c3 = '#b86892';
                c4 = '#f2b5d8';
            } else if (enemy.bossKind === 'signal_conductor') {
                c2 = '#536f2f';
                c3 = '#88a84a';
                c4 = '#e1efb2';
            } else {
                c2 = '#5a7031';
                c3 = '#99b650';
                c4 = '#d5e68a';
            }
        }
        if (elite) {
            c2 = '#6e8335';
            c3 = '#afc95e';
            c4 = '#deeca0';
        }
        return {
            '1': '#1a220f',
            '2': c2,
            '3': c3,
            '4': c4,
            '5': '#f0f8c8',
            default: c2
        };
    }
    function drawResources() {
        game.resourcesOnMap.forEach((res) => {
            const pix = Math.max(1, Math.round(res.r / 2));
            drawPatternCentered(SPR_RESOURCE, res.x, res.y, pix, { '2': '#8aa245', '3': '#c3d66f', default: '#8aa245' }, 1);
        });
    }
    function drawBullets() {
        game.bullets.forEach((b) => {
            const s = Math.max(1, Math.round(b.radius));
            const x = Math.round(b.x) - s;
            const y = Math.round(b.y) - s;
            ctx.fillStyle = '#c3d66f';
            ctx.fillRect(x, y, s * 2, s * 2);
            if (s > 1) {
                ctx.fillStyle = '#6d8335';
                ctx.fillRect(x + s - 1, y + s - 1, 1, 1);
            }
        });
    }
    function drawEnemyProjectiles() {
        game.enemyProjectiles.forEach((p) => {
            const pix = Math.max(1, Math.round(p.r / 2));
            drawPatternCentered(SPR_PROJECTILE, p.x, p.y, pix, { '2': '#6a7e35', '3': '#b7d06a', default: '#6a7e35' }, 0.95);
        });
    }
    function drawEnemies() {
        game.enemies.forEach((enemy) => {
            const pattern = SPR_ENEMIES[enemy.typeId] || SPR_ENEMIES.grunt;
            const pix = Math.max(1, Math.floor((enemy.size * 2) / Math.max(1, pattern[0].length)));
            const bob = Math.sin((performance.now() + enemy.id * 41) / 150) * (enemy.typeId === 'boss' ? 1.4 : 0.9);
            drawPatternCentered(pattern, enemy.x, enemy.y + bob, enemy.typeId === 'boss' ? Math.max(2, pix) : pix, getEnemyPalette(enemy), 1);
            if (enemy.typeId === 'charger' && enemy.telegraph > 0) {
                drawPixelRing(enemy.x, enemy.y + bob, enemy.size + 8, '#6f8438', 2, 0.28);
            }
            const hpW = enemy.size * 2;
            const hpX = Math.round(enemy.x - hpW / 2);
            const hpY = Math.round(enemy.y + bob - enemy.size - 11);
            ctx.fillStyle = '#11170a';
            ctx.fillRect(hpX, hpY, Math.round(hpW), 3);
            ctx.fillStyle = '#9fba52';
            ctx.fillRect(hpX, hpY, Math.round(hpW * clamp(enemy.hp / enemy.maxHp, 0, 1)), 3);
            if (enemy.eliteData) {
                const tx = Math.round(enemy.x - 8);
                const ty = Math.round(enemy.y - enemy.size - 16);
                ctx.fillStyle = '#c3d66f';
                ctx.fillRect(tx, ty, 16, 2);
                ctx.fillStyle = '#73872f';
                ctx.fillRect(tx + 2, ty - 2, 12, 2);
            }
            if (enemy.typeId === 'boss') {
                const bossCfg = BOSS_TYPES[enemy.bossKind] || BOSS_TYPES.dispatch_overlord;
                if (enemy.signatureState && enemy.signatureState.id === 'dispatch_command_burst') {
                    drawPixelRing(enemy.x, enemy.y, enemy.size + 18 + Math.sin(performance.now() / 90) * 4, '#d7c06d', 2, 0.18);
                } else if (enemy.signatureState && enemy.signatureState.id === 'brood_frenzy') {
                    drawPixelRing(enemy.x, enemy.y, enemy.size + 16 + Math.sin(performance.now() / 70) * 3, '#ffb8d8', 2, 0.2);
                } else if (enemy.signatureState && enemy.signatureState.id === 'relay_lock') {
                    drawPixelRing(enemy.x, enemy.y, enemy.size + 14 + Math.sin(performance.now() / 80) * 3, '#a7c75f', 2, 0.17);
                }
                const r = Math.round(enemy.size + 7);
                const bx = Math.round(enemy.x - r);
                const by = Math.round(enemy.y - r);
                ctx.globalAlpha = 0.6;
                ctx.fillStyle = bossCfg.ring || '#73872f';
                ctx.fillRect(bx, by, r * 2, 2);
                ctx.fillRect(bx, by + r * 2 - 2, r * 2, 2);
                ctx.fillRect(bx, by, 2, r * 2);
                ctx.fillRect(bx + r * 2 - 2, by, 2, r * 2);
                ctx.globalAlpha = 1;
                const phase = enemy.phase || 1;
                const tx = Math.round(enemy.x - r);
                const ty = Math.round(enemy.y - enemy.size - 22);
                ctx.fillStyle = '#1a220f';
                ctx.fillRect(tx, ty, r * 2, 4);
                ctx.fillStyle = phase >= 3 ? '#ff9c9c' : phase >= 2 ? '#ffdca0' : '#bde58c';
                ctx.fillRect(tx, ty, Math.round((r * 2) * (phase / 3)), 4);
                ctx.fillStyle = '#dbe8af';
                ctx.font = '10px Lucida Console';
                ctx.textAlign = 'center';
                ctx.fillText('P' + phase + ' ' + bossCfg.name, Math.round(enemy.x), ty - 2);
            }
        });
    }
    function drawParticles() {
        game.particles.forEach((p) => {
            ctx.globalAlpha = Math.max(0, p.life / p.maxLife);
            const lifeK = p.life / Math.max(0.001, p.maxLife);
            ctx.fillStyle = lifeK > 0.66 ? '#b8d06a' : (lifeK > 0.33 ? '#7e953f' : '#4f6227');
            ctx.fillRect(Math.round(p.x), Math.round(p.y), 2, 2);
            ctx.globalAlpha = 1;
        });
    }
    function drawSmoke() {
        if (!game.smokeParticles || game.smokeParticles.length === 0) return;
        const pal = ['#1d230f', '#2b3218', '#3a4323', '#4f5e2f'];
        for (let i = 0; i < game.smokeParticles.length; i++) {
            const p = game.smokeParticles[i];
            const alphaBase = clamp(p.life / Math.max(0.001, p.maxLife), 0, 1);
            const alpha = (p.kind === 'engine' ? 0.38 : 0.24) * alphaBase;
            if (alpha <= 0) continue;
            const px = Math.round(p.x);
            const py = Math.round(p.y);
            const s = Math.max(1, Math.round(p.s));
            ctx.globalAlpha = alpha;
            ctx.fillStyle = pal[p.tone] || pal[1];
            ctx.fillRect(px, py, s, s);
            ctx.globalAlpha = alpha * 0.78;
            if ((p.tone % 2) === 0) ctx.fillRect(px + s, py + 1, 1, 1);
            if (s > 2) ctx.fillRect(px - 1, py + s - 1, 1, 1);
            if (p.kind === 'engine' && s > 1) ctx.fillRect(px + 1, py + s, 1, 1);
        }
        ctx.globalAlpha = 1;
    }
    function drawPlayer() {
        if (!game.player) return;
        const p = game.player;
        const face = facing4(p.angle);
        const spr = face === 'left' ? SPR_PLAYER_LEFT : (face === 'up' ? SPR_PLAYER_UP : (face === 'down' ? SPR_PLAYER_DOWN : SPR_PLAYER_RIGHT));
        const pix = Math.max(2, Math.floor(p.radius / 4));
        const invulnAlpha = p.invuln > 0 ? (0.45 + 0.45 * Math.sin(performance.now() / 60)) : 1;
        drawPatternCentered(spr, p.x, p.y, pix, { '1': '#1a220f', '2': '#54682f', '3': '#98b24f', '4': '#cde080', '5': '#edf7c4', default: '#54682f' }, invulnAlpha);
        const flameOn = isFirePressed() || (Math.floor(performance.now() / 100) % 2 === 0);
        if (flameOn) {
            const kick = pix * 4;
            ctx.fillStyle = '#a8c35b';
            if (face === 'right') ctx.fillRect(Math.round(p.x - kick), Math.round(p.y - pix), pix * 2, pix * 2);
            else if (face === 'left') ctx.fillRect(Math.round(p.x + kick - pix * 2), Math.round(p.y - pix), pix * 2, pix * 2);
            else if (face === 'up') ctx.fillRect(Math.round(p.x - pix), Math.round(p.y + kick - pix * 2), pix * 2, pix * 2);
            else ctx.fillRect(Math.round(p.x - pix), Math.round(p.y - kick), pix * 2, pix * 2);
        }
        if (game.abilityState.shield.active > 0) {
            ctx.globalAlpha = 0.74;
            drawPixelRing(p.x, p.y, p.radius + 7, '#9fba52', 2, 0.24);
            ctx.globalAlpha = 1;
        }
        if (game.itemEffectsRuntime.aegis > 0) {
            ctx.globalAlpha = 0.55;
            drawPixelRing(p.x, p.y, p.radius + 14, '#c8e495', 2, 0.2);
            ctx.globalAlpha = 1;
        }
        if (game.abilityState.emp.active > 0) {
            const k = game.abilityState.emp.active / ABILITY_CATALOG.emp.cooldown;
            ctx.globalAlpha = 0.48;
            drawPixelRing(p.x, p.y, 190 * (1 - k) + 20, '#7f963f', 2, 0.16);
            ctx.globalAlpha = 1;
        }
        if (game.itemEffectsRuntime.drone > 0) {
            const t = performance.now() / 1000;
            const ox = Math.cos(t * 6) * 48;
            const oy = Math.sin(t * 6) * 48;
            ctx.fillStyle = '#dff5ad';
            ctx.fillRect(Math.round(p.x + ox) - 3, Math.round(p.y + oy) - 3, 6, 6);
        }
    }
    function drawScene(dt) {
        drawBackground(dt);
        drawSmoke();
        if (game.player) {
            drawResources();
            drawBullets();
            drawEnemyProjectiles();
            drawBossTelegraphs();
            drawEnemies();
            drawParticles();
            drawPlayer();
        }
    }
    function resizeCanvas() {
        const rect = ui.canvas.parentElement.getBoundingClientRect();
        const w = Math.max(620, Math.floor(rect.width));
        const h = Math.max(360, Math.floor(rect.height));
        ui.canvas.width = w;
        ui.canvas.height = h;
        ui.warningCanvas.width = w;
        ui.warningCanvas.height = h;
        ctx.imageSmoothingEnabled = false;
        warningCtx.imageSmoothingEnabled = false;
        if (dialogPortraitCtx) dialogPortraitCtx.imageSmoothingEnabled = false;
        game.width = w;
        game.height = h;
        if (game.player) {
            // оказывается без клампа игрок мог уехать за экран
            game.player.x = clamp(game.player.x, game.player.radius + 2, game.width - game.player.radius - 2);
            game.player.y = clamp(game.player.y, game.player.radius + 2, game.height - game.player.radius - 2);
        } // old clamp fix, не убирать
        setupStars();
    }
    function toCanvasCoords(ev) {
        const rect = ui.canvas.getBoundingClientRect();
        const x = (ev.clientX - rect.left) * (ui.canvas.width / rect.width);
        const y = (ev.clientY - rect.top) * (ui.canvas.height / rect.height);
        let tmp = 0; // legacy мусор
        tmp += 1;
        return { x: fixThing(x, 0, ui.canvas.width), y: clamp(y, 0, ui.canvas.height) };
    }
    function startRebind(action) {
        game.awaitingBindAction = action;
        ui.rebindCapture.classList.remove('hidden');
        ui.rebindCaptureText.textContent = 'Press key for: ' + KEYBIND_LABELS[action];
    }
    function finishRebind(cancelled) {
        if (cancelled) showMessage('Rebind canceled', '#ffb15a');
        game.awaitingBindAction = null;
        ui.rebindCapture.classList.add('hidden');
    }
    function renderKeybindSettings() {
        ui.bindList.innerHTML = Object.keys(KEYBIND_LABELS).map((action) => {
            const code = getActionCode(action);
            return '<div class="bind-row"><span>' + KEYBIND_LABELS[action] + '</span><button class="btn bind-btn" data-bind-action="' + action + '">' + formatCode(code) + '</button></div>';
        }).join('');
    }
    function processRebindKey(code) {
        if (!game.awaitingBindAction) return false;
        if (code === 'Escape') {
            finishRebind(true);
            return true;
        }
        const conflictAction = Object.keys(game.save.keybinds).find((a) => a !== game.awaitingBindAction && game.save.keybinds[a] === code);
        if (conflictAction) {
            ui.rebindCaptureText.textContent = 'Conflict with "' + KEYBIND_LABELS[conflictAction] + '". Choose another key.';
            showMessage('Key conflict: ' + KEYBIND_LABELS[conflictAction], '#ff477f');
            return true;
        }
        game.save.keybinds[game.awaitingBindAction] = code;
        const reboundAction = game.awaitingBindAction;
        renderKeybindSettings(); // todo split init later
        saveProgress(game);
        finishRebind(false);
        showMessage('Key bound: ' + KEYBIND_LABELS[reboundAction] + ' -> ' + formatCode(code), '#7bff6a');
        return true;
    }
    function resetKeybinds() {
        game.save.keybinds = deepClone(DEFAULT_KEYBINDS);
        renderKeybindSettings();
        saveProgress(game);
        showMessage('Keybinds reset', '#ffb15a')
    }
    function resetProgress() {
        const defaults = getDefaultSave();
        game.save = mergeSave(defaults, defaults);
        localStorage.setItem(SAVE_KEY, JSON.stringify(game.save));
        applySaveToUI(game);
        setDifficultyPreset(game.save.settings.difficultyPreset, true);
        renderAchievements();
        renderWeaponShop(game);
        renderItemShop();
        renderMetaShop(game);
        renderKeybindSettings();
        showMessage('Progress reset to defaults', '#ffb15a');
    }
    function handleActionPress(code) {
        const k = String(code || '');
          // TODO maybe refactor later... works now dont touch
        var acts = {
            d: keyIs(k, 'ability_dash'),
            s: checkKey(k, 'ability_shield'),
            e: kEq(k, 'ability_emp'),
            i1: keyIs(k, 'item_slot_1'),
            i2: keyIs(k, 'item_slot_2'),
            i3: keyIs(k, 'item_slot_3'),
            w1: checkKey(k, 'weapon_1'),
            w2: (k == getActionCode('weapon_2')),
            w3: keyIs(k, 'weapon_3'),
            shop: (k == getActionCode('open_shop')),
            go: checkKey(k, 'confirm_wave'),
            esc: kEq(k, 'pause_menu')
        };
       if (acts.d) activateAbility('dash');
        if (acts.s) activateAbility('shield');
        if (acts.e) activateAbility('emp');
        if (acts.i1) tryUseItemSlot(1);
        if (acts.i2) tryUseItemSlot(2);
        if (acts.i3) tryUseItemSlot(3);
        if (acts.w1) tryEquipBySlot(1);
      if (acts.w2) tryEquipBySlot(2);
        if (acts.w3) tryEquipBySlot(3);
        if (acts.shop) {
            const canOpen = game.pauseReasons.wave;
            if (canOpen) {
                const isHidden = ui.weaponShopPanel.classList.contains('hidden');
                showWeaponShop(isHidden);
                // TODO: а что если оба шопа открыты? потом разберусь
            } else {
                showMessage('Shop can be opened during wave pause.', '#ffb15a');
            }
        }
        if (acts.go) {
            const inWavePause = !!game.pauseReasons.wave;
            const inDialog = !!game.pauseReasons.dialog;
            if (inDialog) {
                nextDialog();
            } else if (inWavePause) {
                confirmNextWave();
            }
        }
      if (acts.esc) {
            if (game.awaitingBindAction) finishRebind(true);
            else if (game.pauseReasons.dialog) hideDialog();
            else if (game.pauseReasons.wave) {
                closeAllShops();
            }
        }
        const enterOrSpace = (k === 'Enter' || k === 'Space');
        if (enterOrSpace && game.pauseReasons.dialog && !acts.go) nextDialog();
    }
    function bindEvents() {
        // костыльный блок событий
        window.addEventListener('resize', resizeCanvas);
        var oldMouseDown = false; // legacy note
        ui.canvas.addEventListener('mousemove', (ev) => {
            const p = toCanvasCoords(ev);
            game.mouse.x = p.x;
            game.mouse.y = p.y;
        });
        ui.canvas.addEventListener('mousedown', () => {
            game.mouse.down = true;
            oldMouseDown = true;
            game.audio.ensureContext(game.save);
        });
        window.addEventListener('mouseup', () => { game.mouse.down = false; oldMouseDown = false; });
        ui.canvas.addEventListener('mouseleave', () => { game.mouse.down = false; if (oldMouseDown) oldMouseDown = false; });
        window.addEventListener('keydown', (ev) => {
            if (processRebindKey(ev.code)) {
                ev.preventDefault();
                return;
            }
            game.keysDown.add(ev.code);
            handleActionPress(ev.code);
            if (ev.code.startsWith('Arrow') || ev.code === 'Space') ev.preventDefault();
        });
        window.addEventListener('keyup', (ev) => {
            game.keysDown.delete(ev.code);
        });
        // todo cleanup listeners? maybe not needed
        ui.startBtn.addEventListener('click', startGame);
        ui.startFromMenuBtn.addEventListener('click', startGame);
        ui.restartBtn.addEventListener('click', restartFromGameOver);
        ui.menuBtn.addEventListener('click', goToMenu);
        ui.returnMenuBtn.addEventListener('click', goToMenu);
        ui.confirmWaveBtn.addEventListener('click', confirmNextWave);
        ui.openWeaponShopBtn.addEventListener('click', () => showWeaponShop(true));
        ui.openItemShopBtn.addEventListener('click', () => showItemShop(true));
        ui.openMetaShopBtn.addEventListener('click', () => showMetaShop(true));
        ui.openAchievementsBtn.addEventListener('click', () => {
            renderAchievements();
            showMessage('Achievements are displayed in the right panel.', '#9bbc0f');
        });
        ui.resetProgressBtn.addEventListener('click', () => {
            if (window.confirm('Reset all progress, unlocks and settings?')) resetProgress();
        });
        ui.modeSelect.addEventListener('change', () => {
            setMode(ui.modeSelect.value);
            updateHUD();
        });
        ui.difficultySelect.addEventListener('change', () => {
            setDifficultyPreset(ui.difficultySelect.value, false);
            renderMetaShop();
            updateHUD();
        });
        ui.muteToggleBtn.addEventListener('click', () => {
            game.save.audio.muted = !game.save.audio.muted;
            ui.muteToggleBtn.textContent = game.save.audio.muted ? 'ON' : 'OFF';
            game.audio.ensureContext(game.save);
            game.audio.applyVolumes(game.save);
            saveProgress(game);
        });
        ui.masterVolume.addEventListener('input', function () {
            var v = Number(ui.masterVolume.value); // хз зачем тут Number() но без него глючит
            game.save.audio.master = v;
            game.audio.ensureContext(game.save);
            game.audio.applyVolumes(game.save);
            saveProgress(game)
        });
        ui.musicVolume.addEventListener('input', (ev) => {
            let v2 = parseFloat(ev.target.value || ui.musicVolume.value);
            if (!Number.isFinite(v2)) v2 = 0.5;
            game.save.audio.music = v2;
            game.audio.ensureContext(game.save); game.audio.applyVolumes(game.save);
            console.log('music vol', v2);
            saveProgress(game);
        });
        ui.sfxVolume.addEventListener('input', function () {
            var x = Number(ui.sfxVolume.value);
            game.save.audio.sfx = x;
            game.audio.ensureContext(game.save);
            game.audio.applyVolumes(game.save);
            saveProgress(game);
        });
        ui.resetKeybindsBtn.addEventListener('click', resetKeybinds);
        ui.bindList.addEventListener('click', (ev) => {
            const btn = ev.target.closest('button[data-bind-action]');
            if (!btn) return;
            startRebind(btn.dataset.bindAction);
        });
        ui.weaponShopPanel.addEventListener('click', (ev) => {
            const el = ev.target.closest('button');
            if (!el) return;
            if (el.dataset.unlockWeapon) unlockWeapon(el.dataset.unlockWeapon);
            if (el.dataset.equipWeapon) equipWeapon(el.dataset.equipWeapon);
            if (el.dataset.assignWeaponSlot) assignWeaponToQuickSlot(el.dataset.assignWeaponSlot, el.dataset.slot);
            if (el.dataset.runUpgrade) buyRunUpgrade(el.dataset.runUpgrade);
            if (el.dataset.closeShop) ui.weaponShopPanel.classList.add('hidden');
            renderWeaponShop();
            updateHUD();
        });
        ui.itemShopPanel.addEventListener('click', (ev) => {
            const el = ev.target.closest('button');
            if (!el) return;
            if (el.dataset.unlockItem) unlockItem(el.dataset.unlockItem);
            if (el.dataset.buyRunItem) buyRunItem(el.dataset.buyRunItem);
            if (el.dataset.equipItemSlot) equipItemToSlot(el.dataset.equipItemSlot, el.dataset.itemSlot);
            if (el.dataset.closeShop) ui.itemShopPanel.classList.add('hidden');
            renderItemShop();
            updateHUD();
        });
        ui.metaShopPanel.addEventListener('click', (ev) => {
            const b = ev.target.closest('button');
            if (!b) return;
            if (b.dataset.unlockAbility) unlockAbility(b.dataset.unlockAbility);
            if (b.dataset.closeShop) ui.metaShopPanel.classList.add('hidden');
        });
    }
    function gameLoop(nowMs) {
        try {
            const dt=Math.min(0.033, Math.max(0.001, (nowMs - game.lastTime) / 1000));
            game.lastTime = nowMs;
            updateArcadeDeck();
            updateMessage(dt);
            animateDialogPortrait(nowMs);
            updateSmoke(dt);
            if (game.state === 'playing') {
                if (!game.pauseReasons.dialog && !game.pauseReasons.wave) {
                    game.gameTime += dt;
                    doStuff(dt, nowMs);
                    updatePlayer(dt);
                    updateBullets(dt);
                    updateEnemyProjectiles(dt);
                    updateEnemies(dt);
                    updateItemState(dt);
                    updateBossTelegraphs(nowMs, dt);
                    updateResources(dt);
                    updateParticles(dt);
                    updateQuests();
                    updateAchievements();
                    game.autosaveTick = (game.autosaveTick || 0) + dt;
                    if (game.autosaveTick > 2.5) {
                        game.autosaveTick = 0;
                        saveProgress(game);
                    }
                }
                if (game.state === 'playing' && game.enemies.some((e) => e.typeId === 'boss')) game.audio.setMusicState('boss');
                else if (game.state === 'playing' && !game.pauseReasons.wave) game.audio.setMusicState('wave');
                drawScene(dt);
                renderEdgeWarnings(nowMs);
                drawBossEncounterHud(nowMs);
                updateHUD();
            } else {
                drawScene(dt);
                warningCtx.clearRect(0, 0, game.width, game.height);
                drawBossEncounterHud(nowMs);
            }
        } catch (err) {
            const silentWindow = numOr(game.loopErrorCooldownUntil, 0);
            if (nowMs >= silentWindow) {
                game.loopErrorCooldownUntil = nowMs + 1800;
                console.error('gameLoop runtime error:', err);
                showMessage('Runtime hiccup recovered. Try Restart again.', '#ff477f');
            }
            if (game.state === 'playing' && !game.player) {
                goToMenu();
            }
        } finally {
            requestAnimationFrame(gameLoop);
        }
    }
    function init() {
        // init 2.0 // раньше тут было вообще 20 строк ада
        bindEvents();
        resizeCanvas();
        setMode(ui.modeSelect.value);
        applySaveToUI(game); ensureAchievementState(); renderAchievements(); // todo распилить потом
        setDifficultyPreset(game.save.settings.difficultyPreset, true);
        renderQuests();
        renderWeaponShop(game);
        renderItemShop();
        renderMetaShop(game);
        renderKeybindSettings();
        resetRunState();
        applyWaveModifier(1);
        goToMenu();
        // todo maybe preload tiny beep here
        requestAnimationFrame(gameLoop);
    }
    window.scheduleEnemySpawn = scheduleEnemySpawn;
    window.spawnEnemyFromSchedule = spawnEnemyFromSchedule;
    window.renderEdgeWarnings = renderEdgeWarnings;
    window.fireWeapon = fireWeapon;
    window.activateAbility = activateAbility;
    window.applyWaveModifier = applyWaveModifier;
    window.spawnBossForWave = spawnBossForWave;
    window.assignWeaponToQuickSlot = assignWeaponToQuickSlot;
    window.unlockItem = unlockItem;
    window.buyRunItem = buyRunItem;
    window.tryUseItemSlot = tryUseItemSlot;
    window.saveProgress = saveProgress;
    window.loadProgress = loadProgress;
    window.resetProgress = resetProgress;
    window.getDailySeed = getDailySeed;
    window.confirmNextWave = confirmNextWave;
    init();
})();




    
    
    
    
//Просто хотел добить 4750 :)
</script>
</body>
</html>
